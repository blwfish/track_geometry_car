<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Track Geometry Car</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
    background: #1a1a2e;
    color: #e0e0e0;
    font-family: 'Courier New', monospace;
    font-size: 14px;
    overflow-x: hidden;
}
#status-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 12px;
    background: #16213e;
    border-bottom: 1px solid #0f3460;
}
.status-dot {
    display: inline-block;
    width: 10px; height: 10px;
    border-radius: 50%;
    margin-right: 6px;
}
.dot-green { background: #4ade80; }
.dot-red { background: #ef4444; animation: pulse 1s infinite; }
.dot-rec { background: #ef4444; animation: pulse 0.5s infinite; }
@keyframes pulse { 50% { opacity: 0.4; } }
#chart-container {
    padding: 4px;
    position: relative;
}
canvas {
    width: 100%;
    height: 35vh;
    min-height: 180px;
    display: block;
    background: #0f0f23;
    border-radius: 4px;
}
#trace-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    padding: 6px 12px;
    justify-content: center;
}
.trace-toggle {
    display: flex;
    align-items: center;
    gap: 3px;
    padding: 4px 8px;
    border-radius: 4px;
    background: #16213e;
    cursor: pointer;
    font-size: 12px;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
}
.trace-toggle.off { opacity: 0.35; }
.trace-swatch {
    width: 12px; height: 12px;
    border-radius: 2px;
}
#readouts {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    padding: 8px 12px;
}
.readout-group {
    background: #16213e;
    border-radius: 4px;
    padding: 8px;
}
.readout-group h3 {
    font-size: 11px;
    color: #888;
    margin-bottom: 4px;
    font-weight: normal;
    text-transform: uppercase;
}
.readout-row {
    display: flex;
    justify-content: space-between;
    font-size: 13px;
    line-height: 1.6;
}
.readout-label { color: #888; }
.readout-val { color: #e0e0e0; text-align: right; }
#recording-bar {
    display: flex;
    gap: 8px;
    padding: 10px 12px;
    align-items: center;
    justify-content: center;
}
button {
    padding: 10px 20px;
    border: none;
    border-radius: 6px;
    font-family: inherit;
    font-size: 14px;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
}
#btn-start {
    background: #166534;
    color: #fff;
}
#btn-stop {
    background: #991b1b;
    color: #fff;
}
#btn-save {
    background: #1e40af;
    color: #fff;
}
#btn-cal { background: #1e3a5f; color: #8cb4e0; }
#btn-analyze { background: #4c1d95; color: #c4b5fd; }
#cal-msg { font-size: 12px; color: #fbbf24; display: none; }
button:disabled { opacity: 0.4; cursor: default; }
#rec-info {
    font-size: 12px;
    color: #888;
}
#file-manager {
    padding: 8px 12px;
}
#fm-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 6px 8px;
    background: #16213e;
    border-radius: 4px 4px 0 0;
    cursor: pointer;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
}
#fm-header h3 {
    font-size: 12px;
    font-weight: normal;
    color: #aaa;
    text-transform: uppercase;
}
#fm-toggle { color: #666; font-size: 12px; }
#fm-body {
    background: #121a30;
    border-radius: 0 0 4px 4px;
    padding: 6px 8px;
    display: none;
}
#fm-body.open { display: block; }
#flash-bar {
    height: 6px;
    background: #0a0f1e;
    border-radius: 3px;
    margin-bottom: 6px;
    overflow: hidden;
}
#flash-fill {
    height: 100%;
    background: #1e40af;
    border-radius: 3px;
    transition: width 0.3s;
}
#flash-info {
    font-size: 11px;
    color: #666;
    margin-bottom: 6px;
}
.survey-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 0;
    border-top: 1px solid #1a2a4a;
    font-size: 12px;
}
.survey-item:first-child { border-top: none; }
.survey-name { color: #aaa; }
.survey-meta { color: #666; margin-left: 8px; }
.survey-actions { display: flex; gap: 4px; }
.survey-actions button {
    padding: 3px 8px;
    font-size: 11px;
    border-radius: 3px;
}
.btn-dl { background: #1e3a5f; color: #8cb4e0; }
.btn-del { background: #3f1515; color: #e08c8c; }
#wifi-manager { padding: 8px 12px; }
#wm-header {
    display: flex; justify-content: space-between; align-items: center;
    padding: 6px 8px; background: #16213e; border-radius: 4px 4px 0 0;
    cursor: pointer; user-select: none; -webkit-tap-highlight-color: transparent;
}
#wm-header h3 { font-size: 12px; font-weight: normal; color: #aaa; text-transform: uppercase; }
#wm-toggle { color: #666; font-size: 12px; }
#wm-body { background: #121a30; border-radius: 0 0 4px 4px; padding: 6px 8px; display: none; }
#wm-body.open { display: block; }
#wifi-status { font-size: 12px; color: #aaa; margin-bottom: 8px; }
.wifi-net {
    display: flex; justify-content: space-between; align-items: center;
    padding: 6px 4px; border-top: 1px solid #1a2a4a; font-size: 12px; cursor: pointer;
}
.wifi-net:first-child { border-top: none; }
.wifi-net:active { background: #1a2a4a; }
.wifi-ssid { color: #e0e0e0; }
.wifi-meta { color: #666; font-size: 11px; }
#wifi-pass-row { display: none; padding: 8px 0; gap: 6px; align-items: center; }
#wifi-pass-row.show { display: flex; }
#wifi-pass-input {
    flex: 1; background: #0f0f23; color: #e0e0e0; border: 1px solid #333;
    border-radius: 4px; font-family: inherit; font-size: 13px; padding: 6px 8px;
}
.btn-scan { background: #1e3a5f; color: #8cb4e0; padding: 6px 12px; font-size: 12px; }
.btn-connect { background: #166534; color: #fff; padding: 6px 12px; font-size: 12px; }
.btn-forget { background: #991b1b; color: #fff; padding: 6px 12px; font-size: 12px; margin-top: 6px; }
#wifi-msg { font-size: 12px; color: #fbbf24; padding: 4px 0; display: none; }
#geom-group { border: 1px solid #1e3a5f; }
#speed-input:focus { outline: 1px solid #0f3460; }
#analysis { padding: 8px 12px; display: none; }
#analysis.show { display: block; }
#an-header {
    display: flex; justify-content: space-between; align-items: center;
    padding: 6px 8px; background: #16213e; border-radius: 4px 4px 0 0;
    cursor: pointer; user-select: none; -webkit-tap-highlight-color: transparent;
}
#an-header h3 { font-size: 12px; font-weight: normal; color: #aaa; text-transform: uppercase; }
#an-toggle { color: #666; font-size: 12px; }
#an-body { background: #121a30; border-radius: 0 0 4px 4px; padding: 8px; display: none; }
#an-body.open { display: block; }
.an-chart { width: 100%; height: 140px; margin-bottom: 8px; border-radius: 4px; }
.an-label { font-size: 11px; color: #888; margin-bottom: 2px; }
#an-summary { font-size: 12px; color: #aaa; margin-bottom: 8px; line-height: 1.6; }
#an-summary b { color: #e0e0e0; }
.an-legend { font-size: 10px; color: #666; margin-bottom: 6px; }
@media (min-width: 601px) {
    canvas { height: 400px; min-height: 300px; }
    #readouts { grid-template-columns: 1fr 1fr 1fr; }
}
/* Landscape phone: taller chart, compact readouts */
@media (orientation: landscape) and (max-height: 500px) {
    canvas { height: 55vh; min-height: 150px; }
    #readouts { grid-template-columns: 1fr 1fr 1fr 1fr; gap: 4px; padding: 4px 8px; }
    .readout-group { padding: 4px 6px; }
    #recording-bar { padding: 4px 8px; }
    button { padding: 6px 14px; font-size: 12px; }
}
</style>
</head>
<body>

<div id="status-bar">
    <span id="conn-status"><span class="status-dot dot-red"></span>Connecting...</span>
    <span id="rec-status"></span>
</div>

<div id="chart-container">
    <canvas id="chart"></canvas>
</div>

<div id="trace-controls"></div>

<div id="readouts">
    <div class="readout-group">
        <h3>Accel RMS (g)</h3>
        <div class="readout-row"><span class="readout-label">X</span><span class="readout-val" id="ax-rms">-</span></div>
        <div class="readout-row"><span class="readout-label">Y</span><span class="readout-val" id="ay-rms">-</span></div>
        <div class="readout-row"><span class="readout-label">Z</span><span class="readout-val" id="az-rms">-</span></div>
    </div>
    <div class="readout-group">
        <h3>Accel Peak (g)</h3>
        <div class="readout-row"><span class="readout-label">X</span><span class="readout-val" id="ax-pk">-</span></div>
        <div class="readout-row"><span class="readout-label">Y</span><span class="readout-val" id="ay-pk">-</span></div>
        <div class="readout-row"><span class="readout-label">Z</span><span class="readout-val" id="az-pk">-</span></div>
    </div>
    <div class="readout-group">
        <h3>Gyro (°/s)</h3>
        <div class="readout-row"><span class="readout-label">X</span><span class="readout-val" id="gx-val">-</span></div>
        <div class="readout-row"><span class="readout-label">Y</span><span class="readout-val" id="gy-val">-</span></div>
        <div class="readout-row"><span class="readout-label">Z</span><span class="readout-val" id="gz-val">-</span></div>
    </div>
    <div class="readout-group">
        <h3>System</h3>
        <div class="readout-row"><span class="readout-label">Temp</span><span class="readout-val" id="temp-val">-</span></div>
        <div class="readout-row"><span class="readout-label">Rate</span><span class="readout-val" id="rate-val">-</span></div>
        <div class="readout-row"><span class="readout-label">Samples</span><span class="readout-val" id="count-val">-</span></div>
    </div>
    <div class="readout-group imu2-group" style="display:none">
        <h3>Accel2 RMS (g)</h3>
        <div class="readout-row"><span class="readout-label">X</span><span class="readout-val" id="ax2-rms">-</span></div>
        <div class="readout-row"><span class="readout-label">Y</span><span class="readout-val" id="ay2-rms">-</span></div>
        <div class="readout-row"><span class="readout-label">Z</span><span class="readout-val" id="az2-rms">-</span></div>
    </div>
    <div class="readout-group imu2-group" style="display:none">
        <h3>Accel2 Peak (g)</h3>
        <div class="readout-row"><span class="readout-label">X</span><span class="readout-val" id="ax2-pk">-</span></div>
        <div class="readout-row"><span class="readout-label">Y</span><span class="readout-val" id="ay2-pk">-</span></div>
        <div class="readout-row"><span class="readout-label">Z</span><span class="readout-val" id="az2-pk">-</span></div>
    </div>
    <div class="readout-group imu2-group" style="display:none">
        <h3>Gyro2 (°/s)</h3>
        <div class="readout-row"><span class="readout-label">X</span><span class="readout-val" id="gx2-val">-</span></div>
        <div class="readout-row"><span class="readout-label">Y</span><span class="readout-val" id="gy2-val">-</span></div>
        <div class="readout-row"><span class="readout-label">Z</span><span class="readout-val" id="gz2-val">-</span></div>
    </div>
    <div class="readout-group" id="geom-group">
        <h3>Geometry</h3>
        <div class="readout-row"><span class="readout-label">State</span><span class="readout-val" id="geom-state">-</span></div>
        <div class="readout-row"><span class="readout-label">Radius</span><span class="readout-val" id="geom-radius">-</span></div>
        <div class="readout-row"><span class="readout-label">Yaw</span><span class="readout-val" id="geom-yaw">-</span></div>
        <div class="readout-row"><span class="readout-label">Grade</span><span class="readout-val" id="geom-grade">-</span></div>
        <div class="readout-row"><span class="readout-label">SNR</span><span class="readout-val" id="geom-snr">-</span></div>
        <div class="readout-row"><span class="readout-label">Speed</span><span class="readout-val" id="geom-speed">
            <input type="number" id="speed-input" value="10" min="1" max="60" step="1"
                   style="width:36px; background:#0f0f23; color:#e0e0e0; border:1px solid #333;
                          border-radius:3px; font-family:inherit; font-size:12px; text-align:right;
                          padding:1px 3px;">
            <span style="font-size:11px; color:#888;">mph</span>
        </span></div>
    </div>
</div>

<div id="recording-bar">
    <button id="btn-start" onclick="startRec()">Start Recording</button>
    <button id="btn-stop" style="display:none" onclick="stopRec()">Stop Recording</button>
    <button id="btn-save" style="display:none" onclick="saveRec()">Save Survey</button>
    <button id="btn-analyze" style="display:none" onclick="analyzeRec()">Analyze</button>
    <button id="btn-cal" onclick="calibrateGyro()">Calibrate</button>
    <span id="rec-info"></span>
    <span id="cal-msg"></span>
</div>

<div id="analysis">
    <div id="an-header" onclick="toggleAnalysis()">
        <h3>Recording Analysis</h3>
        <span id="an-toggle">&#9660;</span>
    </div>
    <div id="an-body">
        <div id="an-summary"></div>
        <div class="an-label">Ride Quality (vertical accel RMS)</div>
        <div class="an-legend">
            <span style="color:#4ade80">&#9608; Smooth</span> &nbsp;
            <span style="color:#fbbf24">&#9608; Fair</span> &nbsp;
            <span style="color:#ef4444">&#9608; Rough</span>
        </div>
        <canvas class="an-chart" id="an-ride"></canvas>
        <div class="an-label">Curvature (yaw rate, 1s windows)</div>
        <div class="an-legend">
            <span style="color:#60a5fa">&#9608; Left</span> &nbsp;
            <span style="color:#f97316">&#9608; Right</span> &nbsp;
            <span style="color:#4ade80">&#9608; Straight</span>
        </div>
        <canvas class="an-chart" id="an-curve"></canvas>
        <div class="an-label">Spectrum (Z-accel FFT, 0-50Hz)</div>
        <canvas class="an-chart" id="an-spectrum"></canvas>
    </div>
</div>

<div id="file-manager">
    <div id="fm-header" onclick="toggleFileManager()">
        <h3>Saved Surveys</h3>
        <span id="fm-toggle">&#9660;</span>
    </div>
    <div id="fm-body">
        <div id="flash-bar"><div id="flash-fill" style="width:0%"></div></div>
        <div id="flash-info">Flash: --</div>
        <div id="survey-list"></div>
    </div>
</div>

<div id="wifi-manager">
    <div id="wm-header" onclick="toggleWifiManager()">
        <h3>WiFi Settings</h3>
        <span id="wm-toggle">&#9660;</span>
    </div>
    <div id="wm-body">
        <div id="wifi-status">Loading...</div>
        <button class="btn-scan" onclick="wifiScan()">Scan Networks</button>
        <div id="wifi-networks"></div>
        <div id="wifi-pass-row">
            <input type="password" id="wifi-pass-input" placeholder="Password">
            <button class="btn-connect" onclick="wifiConnect()">Connect</button>
        </div>
        <div id="wifi-msg"></div>
        <button class="btn-forget" id="btn-forget" style="display:none" onclick="wifiForget()">Forget Network</button>
    </div>
</div>

<script>
// ===== Configuration =====
const ACCEL_SCALE = 16384.0;
const GYRO_SCALE = 131.0;
const TEMP_SCALE = 340.0;
const TEMP_OFFSET = 36.53;
const CHART_SECONDS = 30;
const MAX_POINTS = CHART_SECONDS * 100;
const GYRO_NOISE_DPS = 0.05;  // MPU-6050 noise floor
const CURVE_THRESHOLD_DPS = 0.3;  // Below this = straight

// ===== Trace definitions =====
const TRACES = [
    { key: 'ax', label: 'aX', color: '#ff4444', group: 'accel', on: true },
    { key: 'ay', label: 'aY', color: '#44ff44', group: 'accel', on: true },
    { key: 'az', label: 'aZ', color: '#4488ff', group: 'accel', on: true },
    { key: 'gx', label: 'gX', color: '#ffaa44', group: 'gyro', on: true },
    { key: 'gy', label: 'gY', color: '#aa44ff', group: 'gyro', on: true },
    { key: 'gz', label: 'gZ', color: '#44ffff', group: 'gyro', on: true },
    // IMU #2 traces — dashed style, dimmer colors, hidden by default
    { key: 'ax2', label: 'aX2', color: '#cc2222', group: 'accel', on: false, imu2: true },
    { key: 'ay2', label: 'aY2', color: '#22cc22', group: 'accel', on: false, imu2: true },
    { key: 'az2', label: 'aZ2', color: '#2266cc', group: 'accel', on: false, imu2: true },
    { key: 'gx2', label: 'gX2', color: '#cc8822', group: 'gyro', on: false, imu2: true },
    { key: 'gy2', label: 'gY2', color: '#8822cc', group: 'gyro', on: false, imu2: true },
    { key: 'gz2', label: 'gZ2', color: '#22cccc', group: 'gyro', on: false, imu2: true },
];
let dualImuDetected = false;  // set true when non-zero IMU2 data arrives

// ===== Data store (circular typed arrays) =====
const data = {};
TRACES.forEach(t => data[t.key] = new Float32Array(MAX_POINTS));
let dataHead = 0, dataCount = 0;

// ===== Recording state =====
let recording = false;
let recSamples = [];
let recStart = 0;
let recTimer = null;

// Show IMU2 UI elements when dual IMU is detected
function showImu2UI() {
    document.querySelectorAll('.imu2-group').forEach(el => el.style.display = '');
    // Enable IMU2 trace toggle buttons
    document.querySelectorAll('.trace-toggle.imu2').forEach(el => el.style.display = '');
}

// ===== WebSocket =====
let ws = null;
let reconnectTimer = null;

function wsConnect() {
    const url = 'ws://' + location.host + '/ws';
    ws = new WebSocket(url);
    ws.binaryType = 'arraybuffer';

    ws.onopen = () => {
        document.getElementById('conn-status').innerHTML =
            '<span class="status-dot dot-green"></span>Connected';
        if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
        // Fetch flash status on connect
        fetchStatus();
        fetchSurveys();
    };

    ws.onclose = () => {
        document.getElementById('conn-status').innerHTML =
            '<span class="status-dot dot-red"></span>Disconnected';
        reconnectTimer = setTimeout(wsConnect, 2000);
    };

    ws.onerror = () => ws.close();
    ws.onmessage = (ev) => parseFrame(ev.data);
}

function parseFrame(buf) {
    const v = new DataView(buf);
    const type = v.getUint8(0);

    if (type === 0x01) {
        // Raw sample batch — 30 bytes per sample (dual IMU format)
        const count = v.getUint8(1);
        for (let i = 0; i < count; i++) {
            const o = 2 + i * 30;
            const s = {
                ts: v.getUint32(o, true),
                ax: v.getInt16(o + 4, true) / ACCEL_SCALE,
                ay: v.getInt16(o + 6, true) / ACCEL_SCALE,
                az: v.getInt16(o + 8, true) / ACCEL_SCALE,
                gx: v.getInt16(o + 10, true) / GYRO_SCALE,
                gy: v.getInt16(o + 12, true) / GYRO_SCALE,
                gz: v.getInt16(o + 14, true) / GYRO_SCALE,
                temp: v.getInt16(o + 16, true) / TEMP_SCALE + TEMP_OFFSET,
                // IMU #2 (zero when single-IMU)
                ax2: v.getInt16(o + 18, true) / ACCEL_SCALE,
                ay2: v.getInt16(o + 20, true) / ACCEL_SCALE,
                az2: v.getInt16(o + 22, true) / ACCEL_SCALE,
                gx2: v.getInt16(o + 24, true) / GYRO_SCALE,
                gy2: v.getInt16(o + 26, true) / GYRO_SCALE,
                gz2: v.getInt16(o + 28, true) / GYRO_SCALE,
            };
            // Detect dual IMU: if any IMU2 field is non-zero
            if (!dualImuDetected && (s.ax2 || s.ay2 || s.az2 || s.gx2 || s.gy2 || s.gz2)) {
                dualImuDetected = true;
                showImu2UI();
            }
            addSample(s);
            if (recording) recSamples.push(s);
        }
    } else if (type === 0x02) {
        // 1-second summary
        parseSummary(v);
    } else if (type === 0x03) {
        // Recording status notification from ESP32
        parseRecStatus(v);
    }
}

function addSample(s) {
    const idx = dataHead;
    TRACES.forEach(t => data[t.key][idx] = s[t.key]);
    dataHead = (dataHead + 1) % MAX_POINTS;
    if (dataCount < MAX_POINTS) dataCount++;
}

function parseSummary(v) {
    // summary_1s_t layout: timestamp(4) + 13 floats(52) + sample_count(4) + sample_rate(4)
    // + 12 IMU2 floats(48)
    // Byte 0 is frame type (0x02), data starts at byte 1
    let o = 1;
    const f = () => { const val = v.getFloat32(o, true); o += 4; return val; };
    const u = () => { const val = v.getUint32(o, true); o += 4; return val; };

    u(); // timestamp_ms — skip
    const axRms = f(), ayRms = f(), azRms = f();
    const axPk = f(), ayPk = f(), azPk = f();
    const gxRms = f(), gyRms = f(), gzRms = f();
    const gxMean = f(), gyMean = f(), gzMean = f();
    const temp = f();
    const count = u();
    const rate = f();

    // IMU #2 summary fields
    const ax2Rms = f(), ay2Rms = f(), az2Rms = f();
    const ax2Pk = f(), ay2Pk = f(), az2Pk = f();
    const gx2Rms = f(), gy2Rms = f(), gz2Rms = f();
    const gx2Mean = f(), gy2Mean = f(), gz2Mean = f();
    // Accel means (appended fields for grade computation)
    const axMean = f(), ayMean = f(), azMean = f();

    document.getElementById('ax-rms').textContent = axRms.toFixed(4);
    document.getElementById('ay-rms').textContent = ayRms.toFixed(4);
    document.getElementById('az-rms').textContent = azRms.toFixed(4);
    document.getElementById('ax-pk').textContent = axPk.toFixed(4);
    document.getElementById('ay-pk').textContent = ayPk.toFixed(4);
    document.getElementById('az-pk').textContent = azPk.toFixed(4);
    document.getElementById('gx-val').textContent = gxRms.toFixed(2);
    document.getElementById('gy-val').textContent = gyRms.toFixed(2);
    document.getElementById('gz-val').textContent = gzRms.toFixed(2);
    document.getElementById('temp-val').textContent = temp.toFixed(1) + '°C';
    document.getElementById('count-val').textContent = count.toLocaleString();
    document.getElementById('rate-val').textContent = rate.toFixed(1) + ' Hz';

    // IMU #2 readouts (only visible when dual IMU detected)
    if (dualImuDetected) {
        document.getElementById('ax2-rms').textContent = ax2Rms.toFixed(4);
        document.getElementById('ay2-rms').textContent = ay2Rms.toFixed(4);
        document.getElementById('az2-rms').textContent = az2Rms.toFixed(4);
        document.getElementById('ax2-pk').textContent = ax2Pk.toFixed(4);
        document.getElementById('ay2-pk').textContent = ay2Pk.toFixed(4);
        document.getElementById('az2-pk').textContent = az2Pk.toFixed(4);
        document.getElementById('gx2-val').textContent = gx2Rms.toFixed(2);
        document.getElementById('gy2-val').textContent = gy2Rms.toFixed(2);
        document.getElementById('gz2-val').textContent = gz2Rms.toFixed(2);
    }

    // Geometry computation from 1-second mean yaw rate and accel means
    updateGeometry(gzMean, azRms, axMean, ayMean, azMean);
}

function updateGeometry(yawMeanDps, azRms, axMean, ayMean, azMean) {
    const absYaw = Math.abs(yawMeanDps);
    const snr = absYaw / GYRO_NOISE_DPS;
    const speedMph = parseFloat(document.getElementById('speed-input').value) || 10;
    // Convert scale mph to model mm/s (HO = 1:87)
    const speedMms = speedMph * 447.04 / 87.0;  // mph to mm/s prototype, then /87

    const stateEl = document.getElementById('geom-state');
    const radiusEl = document.getElementById('geom-radius');
    const yawEl = document.getElementById('geom-yaw');
    const snrEl = document.getElementById('geom-snr');
    const gradeEl = document.getElementById('geom-grade');

    yawEl.textContent = absYaw.toFixed(2) + ' \u00b0/s';
    snrEl.textContent = snr.toFixed(0);

    // Grade from longitudinal tilt: atan2(ax, az) gives pitch angle
    // On level track ax≈0, az≈1g. Positive ax = uphill (nose up).
    // Grade % = tan(pitch) * 100 = (ax/az) * 100
    if (axMean !== undefined && azMean !== undefined && azMean !== 0) {
        const gradePct = (axMean / azMean) * 100;
        const absGrade = Math.abs(gradePct);
        if (absGrade < 0.1) {
            gradeEl.textContent = 'Level';
            gradeEl.style.color = '#4ade80';
        } else {
            const dir = gradePct > 0 ? '\u2191' : '\u2193';  // ↑ uphill, ↓ downhill
            gradeEl.textContent = dir + ' ' + absGrade.toFixed(1) + '%';
            gradeEl.style.color = absGrade > 2 ? '#fbbf24' : '#e0e0e0';
        }
    }

    if (absYaw < CURVE_THRESHOLD_DPS) {
        // Straight track
        stateEl.textContent = 'Straight';
        stateEl.style.color = '#4ade80';
        radiusEl.textContent = '-';
        radiusEl.style.color = '#e0e0e0';
        snrEl.style.color = '#888';

        // Ride quality from vertical accel RMS
        if (azRms < 1.01) {
            stateEl.textContent = 'Straight \u2022 Smooth';
        } else if (azRms < 1.03) {
            stateEl.textContent = 'Straight \u2022 Fair';
        } else {
            stateEl.textContent = 'Straight \u2022 Rough';
            stateEl.style.color = '#fbbf24';
        }
    } else {
        // In a curve
        const yawRad = absYaw * Math.PI / 180;
        const radiusMm = speedMms / yawRad;
        const radiusIn = radiusMm / 25.4;
        const dir = yawMeanDps > 0 ? 'L' : 'R';

        stateEl.textContent = 'Curve ' + dir;
        stateEl.style.color = '#60a5fa';

        if (radiusIn < 100) {
            radiusEl.textContent = radiusIn.toFixed(1) + '"';
        } else {
            radiusEl.textContent = radiusIn.toFixed(0) + '"';
        }

        // Color code SNR: green=good, yellow=marginal, red=noisy
        if (snr >= 20) {
            snrEl.style.color = '#4ade80';
            radiusEl.style.color = '#e0e0e0';
        } else if (snr >= 10) {
            snrEl.style.color = '#fbbf24';
            radiusEl.style.color = '#fbbf24';
        } else {
            snrEl.style.color = '#ef4444';
            radiusEl.style.color = '#ef4444';
        }
    }
}

// ===== Strip Chart =====
const canvas = document.getElementById('chart');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * (window.devicePixelRatio || 1);
    canvas.height = rect.height * (window.devicePixelRatio || 1);
    ctx.scale(window.devicePixelRatio || 1, window.devicePixelRatio || 1);
}
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 150));
resizeCanvas();

// Smoothed range state — expand instantly, contract slowly to avoid axis flicker
const smoothRange = {
    accel: { min: null, max: null },
    gyro:  { min: null, max: null }
};
const RANGE_DECAY = 0.03;  // Per-frame contraction rate (~1s at 60fps)

function findRange(traces, nPoints, group) {
    let yMin = Infinity, yMax = -Infinity;
    for (const t of traces) {
        for (let i = 0; i < nPoints; i++) {
            const di = (dataHead - dataCount + Math.floor(i * dataCount / nPoints) + MAX_POINTS) % MAX_POINTS;
            const val = data[t.key][di];
            if (val < yMin) yMin = val;
            if (val > yMax) yMax = val;
        }
    }
    const rawRange = yMax - yMin || 0.01;
    const padded = { min: yMin - rawRange * 0.1, max: yMax + rawRange * 0.1 };

    // Apply smoothing: expand instantly, contract slowly
    const sr = smoothRange[group];
    if (sr.min === null) {
        sr.min = padded.min;
        sr.max = padded.max;
    } else {
        // Expand instantly
        if (padded.min < sr.min) sr.min = padded.min;
        if (padded.max > sr.max) sr.max = padded.max;
        // Contract slowly toward data range
        sr.min += (padded.min - sr.min) * RANGE_DECAY;
        sr.max += (padded.max - sr.max) * RANGE_DECAY;
    }

    return { min: sr.min, max: sr.max };
}

function drawChart() {
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;

    const activeAccel = TRACES.filter(t => t.on && t.group === 'accel');
    const activeGyro = TRACES.filter(t => t.on && t.group === 'gyro');
    const hasAccel = activeAccel.length > 0;
    const hasGyro = activeGyro.length > 0;

    // Adjust margins: right margin grows when gyro axis is visible
    const margin = { top: 10, right: hasGyro ? 50 : 10, bottom: 20, left: hasAccel ? 50 : 10 };
    // If only gyro is active, shrink left; if only accel, shrink right
    if (!hasAccel && hasGyro) margin.left = 10;
    if (hasAccel && !hasGyro) margin.right = 10;
    const plotW = w - margin.left - margin.right;
    const plotH = h - margin.top - margin.bottom;

    ctx.clearRect(0, 0, w, h);

    if (dataCount < 2) {
        ctx.fillStyle = '#444';
        ctx.font = '14px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('Waiting for data...', w / 2, h / 2);
        requestAnimationFrame(drawChart);
        return;
    }

    if (!hasAccel && !hasGyro) {
        requestAnimationFrame(drawChart);
        return;
    }

    const nPoints = Math.min(dataCount, Math.ceil(plotW));
    const gridLines = 5;

    // Compute independent ranges (with smoothing to prevent axis flicker)
    const accelRange = hasAccel ? findRange(activeAccel, nPoints, 'accel') : null;
    const gyroRange = hasGyro ? findRange(activeGyro, nPoints, 'gyro') : null;

    // Draw grid
    ctx.strokeStyle = '#1a2a4a';
    ctx.lineWidth = 1;
    for (let i = 0; i <= gridLines; i++) {
        const y = margin.top + (plotH * i / gridLines);
        ctx.beginPath();
        ctx.moveTo(margin.left, y);
        ctx.lineTo(w - margin.right, y);
        ctx.stroke();
    }

    // Left axis — Accel (g) — tinted blue to match accel color group
    if (hasAccel) {
        ctx.fillStyle = '#6688cc';
        ctx.font = '10px monospace';
        ctx.textAlign = 'right';
        for (let i = 0; i <= gridLines; i++) {
            const val = accelRange.max - (accelRange.max - accelRange.min) * i / gridLines;
            const y = margin.top + (plotH * i / gridLines);
            ctx.fillText(val.toFixed(3), margin.left - 4, y + 3);
        }
        // Axis label
        ctx.save();
        ctx.translate(10, margin.top + plotH / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillText('g', 0, 0);
        ctx.restore();
    }

    // Right axis — Gyro (°/s) — tinted orange to match gyro color group
    if (hasGyro) {
        ctx.fillStyle = '#ccaa66';
        ctx.font = '10px monospace';
        ctx.textAlign = 'left';
        for (let i = 0; i <= gridLines; i++) {
            const val = gyroRange.max - (gyroRange.max - gyroRange.min) * i / gridLines;
            const y = margin.top + (plotH * i / gridLines);
            ctx.fillText(val.toFixed(1), w - margin.right + 4, y + 3);
        }
        // Axis label
        ctx.save();
        ctx.translate(w - 4, margin.top + plotH / 2);
        ctx.rotate(Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillText('\u00b0/s', 0, 0);
        ctx.restore();
    }

    // Time axis labels
    ctx.fillStyle = '#666';
    ctx.textAlign = 'center';
    const secVisible = dataCount / 100;
    for (let s = 0; s <= Math.min(secVisible, CHART_SECONDS); s += 5) {
        if (s === 0) continue;
        const x = margin.left + plotW - (s / secVisible) * plotW;
        if (x < margin.left) break;
        ctx.fillText('-' + s + 's', x, h - 4);
    }

    // Draw traces — each group uses its own Y scale
    ctx.lineWidth = 1.5;
    const allActive = [...activeAccel, ...activeGyro];
    for (const t of allActive) {
        const range = t.group === 'accel' ? accelRange : gyroRange;
        ctx.strokeStyle = t.color;
        // IMU2 traces use dashed lines to distinguish from IMU1
        if (t.imu2) ctx.setLineDash([4, 3]);
        else ctx.setLineDash([]);
        ctx.beginPath();
        let started = false;
        for (let i = 0; i < nPoints; i++) {
            const di = (dataHead - dataCount + Math.floor(i * dataCount / nPoints) + MAX_POINTS) % MAX_POINTS;
            const val = data[t.key][di];
            const x = margin.left + (i / nPoints) * plotW;
            const y = margin.top + plotH - ((val - range.min) / (range.max - range.min)) * plotH;
            if (!started) { ctx.moveTo(x, y); started = true; }
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
    }
    ctx.setLineDash([]);  // reset

    requestAnimationFrame(drawChart);
}
requestAnimationFrame(drawChart);

// ===== Trace toggle buttons =====
const tcDiv = document.getElementById('trace-controls');
TRACES.forEach((t, i) => {
    const el = document.createElement('div');
    el.className = 'trace-toggle' + (t.on ? '' : ' off') + (t.imu2 ? ' imu2' : '');
    if (t.imu2) el.style.display = 'none';  // hidden until dual IMU detected
    el.innerHTML = `<span class="trace-swatch" style="background:${t.color}"></span>${t.label}`;
    el.onclick = () => {
        t.on = !t.on;
        el.className = 'trace-toggle' + (t.on ? '' : ' off') + (t.imu2 ? ' imu2' : '');
        // Reset range smoothing for this group so scale adapts immediately
        smoothRange[t.group].min = null;
        smoothRange[t.group].max = null;
    };
    tcDiv.appendChild(el);
});

// ===== Recording =====
function startRec() {
    recording = true;
    recSamples = [];
    recStart = Date.now();
    document.getElementById('btn-start').style.display = 'none';
    document.getElementById('btn-stop').style.display = 'inline-block';
    document.getElementById('btn-save').style.display = 'none';
    document.getElementById('btn-analyze').style.display = 'none';
    document.getElementById('analysis').className = '';
    document.getElementById('rec-status').innerHTML =
        '<span class="status-dot dot-rec"></span><span id="rec-time">0:00</span>';

    // Send start command to ESP32
    if (ws && ws.readyState === 1) ws.send(new Uint8Array([0x10]));

    recTimer = setInterval(() => {
        const sec = Math.floor((Date.now() - recStart) / 1000);
        const m = Math.floor(sec / 60);
        const s = (sec % 60).toString().padStart(2, '0');
        document.getElementById('rec-time').textContent = m + ':' + s;
    }, 1000);
}

function stopRec() {
    recording = false;
    clearInterval(recTimer);
    document.getElementById('btn-start').style.display = 'inline-block';
    document.getElementById('btn-stop').style.display = 'none';
    document.getElementById('btn-save').style.display = 'inline-block';
    document.getElementById('btn-analyze').style.display = 'inline-block';
    document.getElementById('rec-status').innerHTML = '';

    // Send stop command to ESP32
    if (ws && ws.readyState === 1) ws.send(new Uint8Array([0x11]));

    const dur = ((Date.now() - recStart) / 1000).toFixed(1);
    document.getElementById('rec-info').textContent =
        recSamples.length.toLocaleString() + ' samples, ' + dur + 's';

    // Refresh file list after recording stops (flash file was saved)
    setTimeout(() => { fetchSurveys(); fetchStatus(); }, 500);
}

function saveRec() {
    // Browser-side JSON save — works for long recordings that exceed flash capacity.
    // Captive portal webviews don't support Blob URLs, so we use a data URI
    // with octet-stream MIME type which triggers a download/share prompt.
    const defaultName = 'survey_' + new Date().toISOString().replace(/[:.]/g, '').slice(0, 15);
    const name = prompt('Survey name:', defaultName);
    if (name === null) return;  // user cancelled
    const filename = (name.trim() || defaultName) + '.json';

    const survey = {
        version: dualImuDetected ? 2 : 1,
        imu_count: dualImuDetected ? 2 : 1,
        car: 'GeometryCar',
        name: name.trim() || defaultName,
        start_time: new Date(recStart).toISOString(),
        duration_sec: (Date.now() - recStart) / 1000,
        sample_rate_hz: 100,
        accel_range_g: 2,
        gyro_range_dps: 250,
        samples: recSamples
    };
    const json = JSON.stringify(survey);
    const dataUri = 'data:application/octet-stream;charset=utf-8,' + encodeURIComponent(json);
    const a = document.createElement('a');
    a.href = dataUri;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

// ===== Flash Recording Status (WS 0x03) =====
function parseRecStatus(v) {
    // Frame: [type:1][recording:1][fnLen:1][filename:N][bytes:4][samples:4]
    const isRec = v.getUint8(1) === 1;
    const fnLen = v.getUint8(2);
    let filename = '';
    for (let i = 0; i < fnLen; i++) filename += String.fromCharCode(v.getUint8(3 + i));
    const bytes = v.getUint32(3 + fnLen, true);
    const samples = v.getUint32(3 + fnLen + 4, true);

    // Update flash recording indicator in status bar
    const recEl = document.getElementById('rec-status');
    if (isRec) {
        recEl.innerHTML = '<span class="status-dot dot-rec"></span>Flash REC';
    } else {
        recEl.innerHTML = '';
        // Recording stopped — refresh file list
        fetchSurveys();
        fetchStatus();
    }
}

// ===== File Manager =====
let fmOpen = false;

function toggleFileManager() {
    fmOpen = !fmOpen;
    document.getElementById('fm-body').className = fmOpen ? 'open' : '';
    document.getElementById('fm-toggle').innerHTML = fmOpen ? '&#9650;' : '&#9660;';
    if (fmOpen) {
        fetchSurveys();
        fetchStatus();
    }
}

function fetchStatus() {
    fetch('/api/status')
        .then(r => r.json())
        .then(st => {
            const used = st.flash_total - st.flash_free;
            const pct = st.flash_total > 0 ? (used / st.flash_total * 100) : 0;
            document.getElementById('flash-fill').style.width = pct.toFixed(1) + '%';
            const freeKB = (st.flash_free / 1024).toFixed(0);
            const totalKB = (st.flash_total / 1024).toFixed(0);
            document.getElementById('flash-info').textContent =
                'Flash: ' + freeKB + ' KB free / ' + totalKB + ' KB total (' +
                st.file_count + ' file' + (st.file_count !== 1 ? 's' : '') + ')';
        })
        .catch(() => {});
}

function fetchSurveys() {
    fetch('/api/surveys')
        .then(r => r.json())
        .then(surveys => {
            const list = document.getElementById('survey-list');
            if (surveys.length === 0) {
                list.innerHTML = '<div style="color:#555;font-size:11px;padding:4px 0">No saved surveys</div>';
                return;
            }
            list.innerHTML = '';
            surveys.forEach(s => {
                const div = document.createElement('div');
                div.className = 'survey-item';
                const sizeKB = (s.size / 1024).toFixed(1);
                const dur = s.duration_sec.toFixed(0);
                div.innerHTML =
                    '<span><span class="survey-name">' + s.name + '</span>' +
                    '<span class="survey-meta">' + sizeKB + ' KB, ' + dur + 's, ' +
                    s.samples + ' smp</span></span>' +
                    '<span class="survey-actions">' +
                    '<button class="btn-dl" onclick="dlSurvey(\'' + s.name + '\')">DL</button>' +
                    '<button class="btn-del" onclick="delSurvey(\'' + s.name + '\')">Del</button>' +
                    '</span>';
                list.appendChild(div);
            });
        })
        .catch(() => {});
}

function dlSurvey(name) {
    const a = document.createElement('a');
    a.href = '/api/survey/' + name;
    a.download = name;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

function delSurvey(name) {
    if (!confirm('Delete ' + name + '?')) return;
    fetch('/api/survey/' + name, { method: 'DELETE' })
        .then(r => {
            if (r.ok) {
                fetchSurveys();
                fetchStatus();
            }
        })
        .catch(() => {});
}

// ===== WiFi Settings =====
let wmOpen = false;
let selectedSSID = '';

function toggleWifiManager() {
    wmOpen = !wmOpen;
    document.getElementById('wm-body').className = wmOpen ? 'open' : '';
    document.getElementById('wm-toggle').innerHTML = wmOpen ? '&#9650;' : '&#9660;';
    if (wmOpen) fetchWifiStatus();
}

function fetchWifiStatus() {
    fetch('/api/wifi/status')
        .then(r => r.json())
        .then(st => {
            const el = document.getElementById('wifi-status');
            const mode = st.mode === 'sta' ? 'Station' : 'Access Point';
            let html = 'Mode: <b style="color:#60a5fa">' + mode + '</b>';
            html += ' &middot; SSID: <b style="color:#e0e0e0">' + st.ssid + '</b>';
            html += ' &middot; IP: ' + st.ip;
            if (st.mode === 'sta') {
                html += ' &middot; RSSI: ' + st.rssi + ' dBm';
            }
            el.innerHTML = html;

            // Show/hide forget button
            document.getElementById('btn-forget').style.display =
                st.mode === 'sta' ? 'inline-block' : 'none';
        })
        .catch(() => {
            document.getElementById('wifi-status').textContent = 'Failed to load WiFi status';
        });
}

function wifiScan() {
    const btn = document.querySelector('.btn-scan');
    btn.disabled = true;
    btn.textContent = 'Scanning...';
    document.getElementById('wifi-networks').innerHTML = '';

    function pollScan() {
        fetch('/api/wifi/scan')
            .then(r => r.json())
            .then(result => {
                if (result.status === 'scanning') {
                    setTimeout(pollScan, 1000);
                    return;
                }
                // result is the array of networks
                btn.disabled = false;
                btn.textContent = 'Scan Networks';
                showScanResults(result);
            })
            .catch(() => {
                btn.disabled = false;
                btn.textContent = 'Scan Networks';
            });
    }
    pollScan();
}

function rssiToSignal(rssi) {
    if (rssi >= -50) return '\u2588\u2587\u2586\u2585';
    if (rssi >= -60) return '\u2588\u2587\u2586\u2581';
    if (rssi >= -70) return '\u2588\u2587\u2581\u2581';
    return '\u2588\u2581\u2581\u2581';
}

function showScanResults(networks) {
    const el = document.getElementById('wifi-networks');
    if (!networks || networks.length === 0) {
        el.innerHTML = '<div style="color:#555;font-size:11px;padding:4px 0">No networks found</div>';
        return;
    }
    // Sort by signal strength
    networks.sort((a, b) => b.rssi - a.rssi);
    el.innerHTML = '';
    networks.forEach(n => {
        const div = document.createElement('div');
        div.className = 'wifi-net';
        const lock = n.open ? '' : '\uD83D\uDD12';
        div.innerHTML = '<span class="wifi-ssid">' + lock + ' ' + n.ssid + '</span>' +
            '<span class="wifi-meta">' + rssiToSignal(n.rssi) + ' ' + n.rssi + 'dB</span>';
        div.onclick = () => selectNetwork(n.ssid, n.open);
        el.appendChild(div);
    });
}

function selectNetwork(ssid, isOpen) {
    selectedSSID = ssid;
    const passRow = document.getElementById('wifi-pass-row');
    if (isOpen) {
        passRow.className = '';
        // Connect immediately for open networks
        wifiConnect();
    } else {
        passRow.className = 'show';
        document.getElementById('wifi-pass-input').value = '';
        document.getElementById('wifi-pass-input').focus();
    }
}

function showWifiMsg(text) {
    const el = document.getElementById('wifi-msg');
    el.textContent = text;
    el.style.display = 'block';
}

function wifiConnect() {
    if (!selectedSSID) return;
    const password = document.getElementById('wifi-pass-input').value;
    showWifiMsg('Connecting to ' + selectedSSID + '... Device will reboot.');

    fetch('/api/wifi/connect', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ssid: selectedSSID, password: password })
    }).catch(() => {});

    // Device will reboot — show message
    setTimeout(() => {
        showWifiMsg('Device is rebooting. Reconnect to your network and navigate to the new IP.');
    }, 2000);
}

function wifiForget() {
    if (!confirm('Forget saved network and reboot into AP mode?')) return;
    showWifiMsg('Clearing credentials... Device will reboot into AP mode.');

    fetch('/api/wifi/disconnect', { method: 'POST' }).catch(() => {});

    setTimeout(() => {
        showWifiMsg('Device is rebooting. Connect to "GeometryCar" WiFi network.');
    }, 2000);
}

// ===== Gyro Calibration =====
function calibrateGyro() {
    if (recording) {
        alert('Stop recording before calibrating.');
        return;
    }
    const btn = document.getElementById('btn-cal');
    const msg = document.getElementById('cal-msg');
    btn.disabled = true;
    msg.textContent = 'Calibrating... keep car stationary';
    msg.style.display = 'inline';

    // Send calibrate command (0x12)
    if (ws && ws.readyState === 1) ws.send(new Uint8Array([0x12]));

    // Calibration takes ~5 seconds (500 samples at 100Hz)
    setTimeout(() => {
        btn.disabled = false;
        msg.textContent = 'Calibration complete';
        setTimeout(() => { msg.style.display = 'none'; }, 3000);
    }, 6000);
}

// ===== Recording Analysis =====
let anOpen = false;

function toggleAnalysis() {
    anOpen = !anOpen;
    document.getElementById('an-body').className = anOpen ? 'open' : '';
    document.getElementById('an-toggle').innerHTML = anOpen ? '&#9650;' : '&#9660;';
}

function analyzeRec() {
    if (recSamples.length < 100) {
        alert('Need at least 1 second of data to analyze.');
        return;
    }
    document.getElementById('analysis').className = 'show';
    anOpen = true;
    document.getElementById('an-body').className = 'open';
    document.getElementById('an-toggle').innerHTML = '&#9650;';

    const n = recSamples.length;
    const dur = n / 100;
    const winSize = 100;  // 1-second windows
    const nWin = Math.floor(n / winSize);

    // Compute 1-second windowed statistics
    const windows = [];
    for (let w = 0; w < nWin; w++) {
        let azSum2 = 0, gzSum = 0;
        for (let i = 0; i < winSize; i++) {
            const s = recSamples[w * winSize + i];
            azSum2 += s.az * s.az;
            gzSum += s.gz;
        }
        const azRms = Math.sqrt(azSum2 / winSize);
        const gzMean = gzSum / winSize;
        windows.push({ azRms, gzMean, t: (w + 0.5) * winSize / 100 });
    }

    // Summary statistics
    let smoothSec = 0, fairSec = 0, roughSec = 0;
    let curveSec = 0, straightSec = 0;
    windows.forEach(w => {
        if (w.azRms < 1.01) smoothSec++;
        else if (w.azRms < 1.03) fairSec++;
        else roughSec++;
        if (Math.abs(w.gzMean) >= 0.3) curveSec++;
        else straightSec++;
    });
    const sumEl = document.getElementById('an-summary');
    sumEl.innerHTML =
        '<b>' + n.toLocaleString() + '</b> samples, <b>' + dur.toFixed(1) + 's</b> duration<br>' +
        'Ride: <b style="color:#4ade80">' + smoothSec + 's smooth</b>, ' +
        '<b style="color:#fbbf24">' + fairSec + 's fair</b>, ' +
        '<b style="color:#ef4444">' + roughSec + 's rough</b><br>' +
        'Track: <b>' + straightSec + 's</b> straight, <b>' + curveSec + 's</b> in curves';

    // --- Ride Quality Chart ---
    drawBarChart('an-ride', windows, w => w.azRms, w => {
        if (w.azRms < 1.01) return '#4ade80';
        if (w.azRms < 1.03) return '#fbbf24';
        return '#ef4444';
    }, 'g');

    // --- Curvature Chart ---
    drawLineChart('an-curve', windows, w => w.gzMean, w => {
        if (Math.abs(w.gzMean) < 0.3) return '#4ade80';
        return w.gzMean > 0 ? '#60a5fa' : '#f97316';
    }, '\u00b0/s');

    // --- Spectrum (FFT) ---
    drawSpectrum('an-spectrum', recSamples);
}

function drawBarChart(canvasId, data, valFn, colorFn, unit) {
    const canvas = document.getElementById(canvasId);
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    const c = canvas.getContext('2d');
    c.scale(dpr, dpr);
    const w = rect.width, h = rect.height;
    const m = { top: 5, right: 8, bottom: 18, left: 40 };
    const pw = w - m.left - m.right, ph = h - m.top - m.bottom;

    c.clearRect(0, 0, w, h);
    c.fillStyle = '#0a0f1e';
    c.fillRect(m.left, m.top, pw, ph);

    if (data.length === 0) return;

    // Auto-scale Y
    let yMin = Infinity, yMax = -Infinity;
    data.forEach(d => { const v = valFn(d); if (v < yMin) yMin = v; if (v > yMax) yMax = v; });
    const yRange = yMax - yMin || 0.01;
    yMin -= yRange * 0.05;
    yMax += yRange * 0.05;
    const yR = yMax - yMin;

    // Y axis labels
    c.fillStyle = '#666';
    c.font = '9px monospace';
    c.textAlign = 'right';
    for (let i = 0; i <= 4; i++) {
        const val = yMax - (yR * i / 4);
        const y = m.top + (ph * i / 4);
        c.fillText(val.toFixed(3), m.left - 3, y + 3);
    }

    // Draw bars
    const barW = Math.max(1, pw / data.length);
    data.forEach((d, i) => {
        const v = valFn(d);
        const barH = ((v - yMin) / yR) * ph;
        const x = m.left + (i / data.length) * pw;
        c.fillStyle = colorFn(d);
        c.fillRect(x, m.top + ph - barH, barW + 0.5, barH);
    });

    // X axis: time
    c.fillStyle = '#666';
    c.textAlign = 'center';
    c.font = '9px monospace';
    const totalSec = data.length;
    const step = totalSec <= 10 ? 1 : totalSec <= 30 ? 5 : totalSec <= 120 ? 10 : 30;
    for (let s = 0; s <= totalSec; s += step) {
        if (s === 0) continue;
        const x = m.left + (s / totalSec) * pw;
        c.fillText(s + 's', x, h - 3);
    }
}

function drawLineChart(canvasId, data, valFn, colorFn, unit) {
    const canvas = document.getElementById(canvasId);
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    const c = canvas.getContext('2d');
    c.scale(dpr, dpr);
    const w = rect.width, h = rect.height;
    const m = { top: 5, right: 8, bottom: 18, left: 40 };
    const pw = w - m.left - m.right, ph = h - m.top - m.bottom;

    c.clearRect(0, 0, w, h);
    c.fillStyle = '#0a0f1e';
    c.fillRect(m.left, m.top, pw, ph);

    if (data.length === 0) return;

    // Auto-scale Y (symmetric around zero for curvature)
    let absMax = 0;
    data.forEach(d => { const v = Math.abs(valFn(d)); if (v > absMax) absMax = v; });
    absMax = Math.max(absMax * 1.1, 0.5);
    const yMin = -absMax, yMax = absMax, yR = yMax - yMin;

    // Zero line
    const zeroY = m.top + ph / 2;
    c.strokeStyle = '#333';
    c.lineWidth = 1;
    c.beginPath();
    c.moveTo(m.left, zeroY);
    c.lineTo(m.left + pw, zeroY);
    c.stroke();

    // Y axis labels
    c.fillStyle = '#666';
    c.font = '9px monospace';
    c.textAlign = 'right';
    for (let i = 0; i <= 4; i++) {
        const val = yMax - (yR * i / 4);
        const y = m.top + (ph * i / 4);
        c.fillText(val.toFixed(1), m.left - 3, y + 3);
    }

    // Draw filled segments colored by direction
    const barW = Math.max(1, pw / data.length);
    data.forEach((d, i) => {
        const v = valFn(d);
        const y = m.top + ph - ((v - yMin) / yR) * ph;
        const x = m.left + (i / data.length) * pw;
        c.fillStyle = colorFn(d);
        if (v >= 0) {
            c.fillRect(x, y, barW + 0.5, zeroY - y);
        } else {
            c.fillRect(x, zeroY, barW + 0.5, y - zeroY);
        }
    });

    // X axis: time
    c.fillStyle = '#666';
    c.textAlign = 'center';
    c.font = '9px monospace';
    const totalSec = data.length;
    const step = totalSec <= 10 ? 1 : totalSec <= 30 ? 5 : totalSec <= 120 ? 10 : 30;
    for (let s = 0; s <= totalSec; s += step) {
        if (s === 0) continue;
        const x = m.left + (s / totalSec) * pw;
        c.fillText(s + 's', x, h - 3);
    }
}

function drawSpectrum(canvasId, samples) {
    const canvas = document.getElementById(canvasId);
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    const c = canvas.getContext('2d');
    c.scale(dpr, dpr);
    const w = rect.width, h = rect.height;
    const m = { top: 5, right: 8, bottom: 18, left: 40 };
    const pw = w - m.left - m.right, ph = h - m.top - m.bottom;

    c.clearRect(0, 0, w, h);
    c.fillStyle = '#0a0f1e';
    c.fillRect(m.left, m.top, pw, ph);

    // Simple DFT for Z-accel (up to 50Hz = Nyquist for 100Hz sample rate)
    // Use at most 1024 samples for performance
    const N = Math.min(samples.length, 1024);
    const az = new Float32Array(N);
    // Take the most recent N samples, remove mean
    let mean = 0;
    for (let i = 0; i < N; i++) mean += samples[samples.length - N + i].az;
    mean /= N;
    for (let i = 0; i < N; i++) az[i] = samples[samples.length - N + i].az - mean;

    // Apply Hann window
    for (let i = 0; i < N; i++) az[i] *= 0.5 * (1 - Math.cos(2 * Math.PI * i / N));

    // Compute magnitude spectrum (only positive frequencies up to 50Hz)
    const nBins = Math.floor(N / 2);
    const mag = new Float32Array(nBins);
    for (let k = 0; k < nBins; k++) {
        let re = 0, im = 0;
        for (let n = 0; n < N; n++) {
            const angle = -2 * Math.PI * k * n / N;
            re += az[n] * Math.cos(angle);
            im += az[n] * Math.sin(angle);
        }
        mag[k] = Math.sqrt(re * re + im * im) / N;
    }

    // Find peak (skip DC bin 0)
    let peakMag = 0, peakBin = 1;
    for (let k = 1; k < nBins; k++) {
        if (mag[k] > peakMag) { peakMag = mag[k]; peakBin = k; }
    }
    const peakHz = (peakBin * 100 / N).toFixed(1);

    // Convert to dB (relative to peak)
    const magDb = new Float32Array(nBins);
    let dbMin = 0, dbMax = -Infinity;
    for (let k = 1; k < nBins; k++) {
        magDb[k] = 20 * Math.log10(Math.max(mag[k], 1e-10) / Math.max(peakMag, 1e-10));
        if (magDb[k] < dbMin) dbMin = magDb[k];
        if (magDb[k] > dbMax) dbMax = magDb[k];
    }
    dbMin = Math.max(dbMin, -60);  // floor at -60dB
    const dbRange = dbMax - dbMin || 1;

    // Y axis labels (dB)
    c.fillStyle = '#666';
    c.font = '9px monospace';
    c.textAlign = 'right';
    for (let i = 0; i <= 4; i++) {
        const val = dbMax - (dbRange * i / 4);
        const y = m.top + (ph * i / 4);
        c.fillText(val.toFixed(0) + 'dB', m.left - 3, y + 3);
    }

    // Draw spectrum line
    c.strokeStyle = '#a78bfa';
    c.lineWidth = 1.5;
    c.beginPath();
    let started = false;
    for (let k = 1; k < nBins; k++) {
        const freq = k * 100 / N;
        const x = m.left + (freq / 50) * pw;
        const db = Math.max(magDb[k], dbMin);
        const y = m.top + ph - ((db - dbMin) / dbRange) * ph;
        if (!started) { c.moveTo(x, y); started = true; }
        else c.lineTo(x, y);
    }
    c.stroke();

    // Mark peak frequency
    const peakX = m.left + (peakBin * 100 / N / 50) * pw;
    const peakY = m.top;
    c.fillStyle = '#fbbf24';
    c.font = '9px monospace';
    c.textAlign = 'center';
    c.fillText(peakHz + 'Hz', peakX, peakY + 10);

    // X axis: frequency
    c.fillStyle = '#666';
    c.textAlign = 'center';
    for (let f = 10; f <= 50; f += 10) {
        const x = m.left + (f / 50) * pw;
        c.fillText(f + 'Hz', x, h - 3);
    }
}

// ===== Init =====
wsConnect();
</script>
</body>
</html>
