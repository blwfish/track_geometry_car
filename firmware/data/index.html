<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Track Geometry Car</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
    background: #1a1a2e;
    color: #e0e0e0;
    font-family: 'Courier New', monospace;
    font-size: 14px;
    overflow-x: hidden;
}
#status-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 12px;
    background: #16213e;
    border-bottom: 1px solid #0f3460;
}
.status-dot {
    display: inline-block;
    width: 10px; height: 10px;
    border-radius: 50%;
    margin-right: 6px;
}
.dot-green { background: #4ade80; }
.dot-red { background: #ef4444; animation: pulse 1s infinite; }
.dot-rec { background: #ef4444; animation: pulse 0.5s infinite; }
@keyframes pulse { 50% { opacity: 0.4; } }
#chart-container {
    padding: 4px;
    position: relative;
}
canvas {
    width: 100%;
    height: 35vh;
    min-height: 180px;
    display: block;
    background: #0f0f23;
    border-radius: 4px;
}
#trace-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    padding: 6px 12px;
    justify-content: center;
}
.trace-toggle {
    display: flex;
    align-items: center;
    gap: 3px;
    padding: 4px 8px;
    border-radius: 4px;
    background: #16213e;
    cursor: pointer;
    font-size: 12px;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
}
.trace-toggle.off { opacity: 0.35; }
.trace-swatch {
    width: 12px; height: 12px;
    border-radius: 2px;
}
#readouts {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    padding: 8px 12px;
}
.readout-group {
    background: #16213e;
    border-radius: 4px;
    padding: 8px;
}
.readout-group h3 {
    font-size: 11px;
    color: #888;
    margin-bottom: 4px;
    font-weight: normal;
    text-transform: uppercase;
}
.readout-row {
    display: flex;
    justify-content: space-between;
    font-size: 13px;
    line-height: 1.6;
}
.readout-label { color: #888; }
.readout-val { color: #e0e0e0; text-align: right; }
#recording-bar {
    display: flex;
    gap: 8px;
    padding: 10px 12px;
    align-items: center;
    justify-content: center;
}
button {
    padding: 10px 20px;
    border: none;
    border-radius: 6px;
    font-family: inherit;
    font-size: 14px;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
}
#btn-start {
    background: #166534;
    color: #fff;
}
#btn-stop {
    background: #991b1b;
    color: #fff;
}
#btn-save {
    background: #1e40af;
    color: #fff;
}
button:disabled { opacity: 0.4; cursor: default; }
#rec-info {
    font-size: 12px;
    color: #888;
}
#file-manager {
    padding: 8px 12px;
}
#fm-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 6px 8px;
    background: #16213e;
    border-radius: 4px 4px 0 0;
    cursor: pointer;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
}
#fm-header h3 {
    font-size: 12px;
    font-weight: normal;
    color: #aaa;
    text-transform: uppercase;
}
#fm-toggle { color: #666; font-size: 12px; }
#fm-body {
    background: #121a30;
    border-radius: 0 0 4px 4px;
    padding: 6px 8px;
    display: none;
}
#fm-body.open { display: block; }
#flash-bar {
    height: 6px;
    background: #0a0f1e;
    border-radius: 3px;
    margin-bottom: 6px;
    overflow: hidden;
}
#flash-fill {
    height: 100%;
    background: #1e40af;
    border-radius: 3px;
    transition: width 0.3s;
}
#flash-info {
    font-size: 11px;
    color: #666;
    margin-bottom: 6px;
}
.survey-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 0;
    border-top: 1px solid #1a2a4a;
    font-size: 12px;
}
.survey-item:first-child { border-top: none; }
.survey-name { color: #aaa; }
.survey-meta { color: #666; margin-left: 8px; }
.survey-actions { display: flex; gap: 4px; }
.survey-actions button {
    padding: 3px 8px;
    font-size: 11px;
    border-radius: 3px;
}
.btn-dl { background: #1e3a5f; color: #8cb4e0; }
.btn-del { background: #3f1515; color: #e08c8c; }
#geom-group { border: 1px solid #1e3a5f; }
#speed-input:focus { outline: 1px solid #0f3460; }
@media (min-width: 601px) {
    canvas { height: 400px; min-height: 300px; }
    #readouts { grid-template-columns: 1fr 1fr 1fr; }
}
/* Landscape phone: taller chart, compact readouts */
@media (orientation: landscape) and (max-height: 500px) {
    canvas { height: 55vh; min-height: 150px; }
    #readouts { grid-template-columns: 1fr 1fr 1fr 1fr; gap: 4px; padding: 4px 8px; }
    .readout-group { padding: 4px 6px; }
    #recording-bar { padding: 4px 8px; }
    button { padding: 6px 14px; font-size: 12px; }
}
</style>
</head>
<body>

<div id="status-bar">
    <span id="conn-status"><span class="status-dot dot-red"></span>Connecting...</span>
    <span id="rec-status"></span>
</div>

<div id="chart-container">
    <canvas id="chart"></canvas>
</div>

<div id="trace-controls"></div>

<div id="readouts">
    <div class="readout-group">
        <h3>Accel RMS (g)</h3>
        <div class="readout-row"><span class="readout-label">X</span><span class="readout-val" id="ax-rms">-</span></div>
        <div class="readout-row"><span class="readout-label">Y</span><span class="readout-val" id="ay-rms">-</span></div>
        <div class="readout-row"><span class="readout-label">Z</span><span class="readout-val" id="az-rms">-</span></div>
    </div>
    <div class="readout-group">
        <h3>Accel Peak (g)</h3>
        <div class="readout-row"><span class="readout-label">X</span><span class="readout-val" id="ax-pk">-</span></div>
        <div class="readout-row"><span class="readout-label">Y</span><span class="readout-val" id="ay-pk">-</span></div>
        <div class="readout-row"><span class="readout-label">Z</span><span class="readout-val" id="az-pk">-</span></div>
    </div>
    <div class="readout-group">
        <h3>Gyro (°/s)</h3>
        <div class="readout-row"><span class="readout-label">X</span><span class="readout-val" id="gx-val">-</span></div>
        <div class="readout-row"><span class="readout-label">Y</span><span class="readout-val" id="gy-val">-</span></div>
        <div class="readout-row"><span class="readout-label">Z</span><span class="readout-val" id="gz-val">-</span></div>
    </div>
    <div class="readout-group">
        <h3>System</h3>
        <div class="readout-row"><span class="readout-label">Temp</span><span class="readout-val" id="temp-val">-</span></div>
        <div class="readout-row"><span class="readout-label">Rate</span><span class="readout-val" id="rate-val">-</span></div>
        <div class="readout-row"><span class="readout-label">Samples</span><span class="readout-val" id="count-val">-</span></div>
    </div>
    <div class="readout-group" id="geom-group">
        <h3>Geometry</h3>
        <div class="readout-row"><span class="readout-label">State</span><span class="readout-val" id="geom-state">-</span></div>
        <div class="readout-row"><span class="readout-label">Radius</span><span class="readout-val" id="geom-radius">-</span></div>
        <div class="readout-row"><span class="readout-label">Yaw</span><span class="readout-val" id="geom-yaw">-</span></div>
        <div class="readout-row"><span class="readout-label">SNR</span><span class="readout-val" id="geom-snr">-</span></div>
        <div class="readout-row"><span class="readout-label">Speed</span><span class="readout-val" id="geom-speed">
            <input type="number" id="speed-input" value="10" min="1" max="60" step="1"
                   style="width:36px; background:#0f0f23; color:#e0e0e0; border:1px solid #333;
                          border-radius:3px; font-family:inherit; font-size:12px; text-align:right;
                          padding:1px 3px;">
            <span style="font-size:11px; color:#888;">mph</span>
        </span></div>
    </div>
</div>

<div id="recording-bar">
    <button id="btn-start" onclick="startRec()">Start Recording</button>
    <button id="btn-stop" style="display:none" onclick="stopRec()">Stop Recording</button>
    <button id="btn-save" style="display:none" onclick="saveRec()">Save Survey</button>
    <span id="rec-info"></span>
</div>

<div id="file-manager">
    <div id="fm-header" onclick="toggleFileManager()">
        <h3>Saved Surveys</h3>
        <span id="fm-toggle">&#9660;</span>
    </div>
    <div id="fm-body">
        <div id="flash-bar"><div id="flash-fill" style="width:0%"></div></div>
        <div id="flash-info">Flash: --</div>
        <div id="survey-list"></div>
    </div>
</div>

<script>
// ===== Configuration =====
const ACCEL_SCALE = 16384.0;
const GYRO_SCALE = 131.0;
const TEMP_SCALE = 340.0;
const TEMP_OFFSET = 36.53;
const CHART_SECONDS = 30;
const MAX_POINTS = CHART_SECONDS * 100;
const GYRO_NOISE_DPS = 0.05;  // MPU-6050 noise floor
const CURVE_THRESHOLD_DPS = 0.3;  // Below this = straight

// ===== Trace definitions =====
const TRACES = [
    { key: 'ax', label: 'aX', color: '#ff4444', group: 'accel', on: true },
    { key: 'ay', label: 'aY', color: '#44ff44', group: 'accel', on: true },
    { key: 'az', label: 'aZ', color: '#4488ff', group: 'accel', on: true },
    { key: 'gx', label: 'gX', color: '#ffaa44', group: 'gyro', on: true },
    { key: 'gy', label: 'gY', color: '#aa44ff', group: 'gyro', on: true },
    { key: 'gz', label: 'gZ', color: '#44ffff', group: 'gyro', on: true },
];

// ===== Data store (circular typed arrays) =====
const data = {};
TRACES.forEach(t => data[t.key] = new Float32Array(MAX_POINTS));
let dataHead = 0, dataCount = 0;

// ===== Recording state =====
let recording = false;
let recSamples = [];
let recStart = 0;
let recTimer = null;

// ===== WebSocket =====
let ws = null;
let reconnectTimer = null;

function wsConnect() {
    const url = 'ws://' + location.host + '/ws';
    ws = new WebSocket(url);
    ws.binaryType = 'arraybuffer';

    ws.onopen = () => {
        document.getElementById('conn-status').innerHTML =
            '<span class="status-dot dot-green"></span>Connected';
        if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
        // Fetch flash status on connect
        fetchStatus();
        fetchSurveys();
    };

    ws.onclose = () => {
        document.getElementById('conn-status').innerHTML =
            '<span class="status-dot dot-red"></span>Disconnected';
        reconnectTimer = setTimeout(wsConnect, 2000);
    };

    ws.onerror = () => ws.close();
    ws.onmessage = (ev) => parseFrame(ev.data);
}

function parseFrame(buf) {
    const v = new DataView(buf);
    const type = v.getUint8(0);

    if (type === 0x01) {
        // Raw sample batch
        const count = v.getUint8(1);
        for (let i = 0; i < count; i++) {
            const o = 2 + i * 18;
            const s = {
                ts: v.getUint32(o, true),
                ax: v.getInt16(o + 4, true) / ACCEL_SCALE,
                ay: v.getInt16(o + 6, true) / ACCEL_SCALE,
                az: v.getInt16(o + 8, true) / ACCEL_SCALE,
                gx: v.getInt16(o + 10, true) / GYRO_SCALE,
                gy: v.getInt16(o + 12, true) / GYRO_SCALE,
                gz: v.getInt16(o + 14, true) / GYRO_SCALE,
                temp: v.getInt16(o + 16, true) / TEMP_SCALE + TEMP_OFFSET
            };
            addSample(s);
            if (recording) recSamples.push(s);
        }
    } else if (type === 0x02) {
        // 1-second summary
        parseSummary(v);
    } else if (type === 0x03) {
        // Recording status notification from ESP32
        parseRecStatus(v);
    }
}

function addSample(s) {
    const idx = dataHead;
    TRACES.forEach(t => data[t.key][idx] = s[t.key]);
    dataHead = (dataHead + 1) % MAX_POINTS;
    if (dataCount < MAX_POINTS) dataCount++;
}

function parseSummary(v) {
    // summary_1s_t layout: timestamp(4) + 13 floats(52) + sample_count(4) + sample_rate(4)
    // Byte 0 is frame type (0x02), data starts at byte 1
    let o = 1;
    const f = () => { const val = v.getFloat32(o, true); o += 4; return val; };
    const u = () => { const val = v.getUint32(o, true); o += 4; return val; };

    u(); // timestamp_ms — skip
    const axRms = f(), ayRms = f(), azRms = f();
    const axPk = f(), ayPk = f(), azPk = f();
    const gxRms = f(), gyRms = f(), gzRms = f();
    const gxMean = f(), gyMean = f(), gzMean = f();
    const temp = f();
    const count = u();
    const rate = f();

    document.getElementById('ax-rms').textContent = axRms.toFixed(4);
    document.getElementById('ay-rms').textContent = ayRms.toFixed(4);
    document.getElementById('az-rms').textContent = azRms.toFixed(4);
    document.getElementById('ax-pk').textContent = axPk.toFixed(4);
    document.getElementById('ay-pk').textContent = ayPk.toFixed(4);
    document.getElementById('az-pk').textContent = azPk.toFixed(4);
    document.getElementById('gx-val').textContent = gxRms.toFixed(2);
    document.getElementById('gy-val').textContent = gyRms.toFixed(2);
    document.getElementById('gz-val').textContent = gzRms.toFixed(2);
    document.getElementById('temp-val').textContent = temp.toFixed(1) + '°C';
    document.getElementById('count-val').textContent = count.toLocaleString();
    document.getElementById('rate-val').textContent = rate.toFixed(1) + ' Hz';

    // Geometry computation from 1-second mean yaw rate
    updateGeometry(gzMean, azRms);
}

function updateGeometry(yawMeanDps, azRms) {
    const absYaw = Math.abs(yawMeanDps);
    const snr = absYaw / GYRO_NOISE_DPS;
    const speedMph = parseFloat(document.getElementById('speed-input').value) || 10;
    // Convert scale mph to model mm/s (HO = 1:87)
    const speedMms = speedMph * 447.04 / 87.0;  // mph to mm/s prototype, then /87

    const stateEl = document.getElementById('geom-state');
    const radiusEl = document.getElementById('geom-radius');
    const yawEl = document.getElementById('geom-yaw');
    const snrEl = document.getElementById('geom-snr');

    yawEl.textContent = absYaw.toFixed(2) + ' \u00b0/s';
    snrEl.textContent = snr.toFixed(0);

    if (absYaw < CURVE_THRESHOLD_DPS) {
        // Straight track
        stateEl.textContent = 'Straight';
        stateEl.style.color = '#4ade80';
        radiusEl.textContent = '-';
        radiusEl.style.color = '#e0e0e0';
        snrEl.style.color = '#888';

        // Ride quality from vertical accel RMS
        if (azRms < 1.01) {
            stateEl.textContent = 'Straight \u2022 Smooth';
        } else if (azRms < 1.03) {
            stateEl.textContent = 'Straight \u2022 Fair';
        } else {
            stateEl.textContent = 'Straight \u2022 Rough';
            stateEl.style.color = '#fbbf24';
        }
    } else {
        // In a curve
        const yawRad = absYaw * Math.PI / 180;
        const radiusMm = speedMms / yawRad;
        const radiusIn = radiusMm / 25.4;
        const dir = yawMeanDps > 0 ? 'L' : 'R';

        stateEl.textContent = 'Curve ' + dir;
        stateEl.style.color = '#60a5fa';

        if (radiusIn < 100) {
            radiusEl.textContent = radiusIn.toFixed(1) + '"';
        } else {
            radiusEl.textContent = radiusIn.toFixed(0) + '"';
        }

        // Color code SNR: green=good, yellow=marginal, red=noisy
        if (snr >= 20) {
            snrEl.style.color = '#4ade80';
            radiusEl.style.color = '#e0e0e0';
        } else if (snr >= 10) {
            snrEl.style.color = '#fbbf24';
            radiusEl.style.color = '#fbbf24';
        } else {
            snrEl.style.color = '#ef4444';
            radiusEl.style.color = '#ef4444';
        }
    }
}

// ===== Strip Chart =====
const canvas = document.getElementById('chart');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * (window.devicePixelRatio || 1);
    canvas.height = rect.height * (window.devicePixelRatio || 1);
    ctx.scale(window.devicePixelRatio || 1, window.devicePixelRatio || 1);
}
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 150));
resizeCanvas();

function findRange(traces, nPoints) {
    let yMin = Infinity, yMax = -Infinity;
    for (const t of traces) {
        for (let i = 0; i < nPoints; i++) {
            const di = (dataHead - dataCount + Math.floor(i * dataCount / nPoints) + MAX_POINTS) % MAX_POINTS;
            const val = data[t.key][di];
            if (val < yMin) yMin = val;
            if (val > yMax) yMax = val;
        }
    }
    const range = yMax - yMin || 0.01;
    return { min: yMin - range * 0.1, max: yMax + range * 0.1 };
}

function drawChart() {
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;

    const activeAccel = TRACES.filter(t => t.on && t.group === 'accel');
    const activeGyro = TRACES.filter(t => t.on && t.group === 'gyro');
    const hasAccel = activeAccel.length > 0;
    const hasGyro = activeGyro.length > 0;

    // Adjust margins: right margin grows when gyro axis is visible
    const margin = { top: 10, right: hasGyro ? 50 : 10, bottom: 20, left: hasAccel ? 50 : 10 };
    // If only gyro is active, shrink left; if only accel, shrink right
    if (!hasAccel && hasGyro) margin.left = 10;
    if (hasAccel && !hasGyro) margin.right = 10;
    const plotW = w - margin.left - margin.right;
    const plotH = h - margin.top - margin.bottom;

    ctx.clearRect(0, 0, w, h);

    if (dataCount < 2) {
        ctx.fillStyle = '#444';
        ctx.font = '14px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('Waiting for data...', w / 2, h / 2);
        requestAnimationFrame(drawChart);
        return;
    }

    if (!hasAccel && !hasGyro) {
        requestAnimationFrame(drawChart);
        return;
    }

    const nPoints = Math.min(dataCount, Math.ceil(plotW));
    const gridLines = 5;

    // Compute independent ranges
    const accelRange = hasAccel ? findRange(activeAccel, nPoints) : null;
    const gyroRange = hasGyro ? findRange(activeGyro, nPoints) : null;

    // Draw grid
    ctx.strokeStyle = '#1a2a4a';
    ctx.lineWidth = 1;
    for (let i = 0; i <= gridLines; i++) {
        const y = margin.top + (plotH * i / gridLines);
        ctx.beginPath();
        ctx.moveTo(margin.left, y);
        ctx.lineTo(w - margin.right, y);
        ctx.stroke();
    }

    // Left axis — Accel (g) — tinted blue to match accel color group
    if (hasAccel) {
        ctx.fillStyle = '#6688cc';
        ctx.font = '10px monospace';
        ctx.textAlign = 'right';
        for (let i = 0; i <= gridLines; i++) {
            const val = accelRange.max - (accelRange.max - accelRange.min) * i / gridLines;
            const y = margin.top + (plotH * i / gridLines);
            ctx.fillText(val.toFixed(3), margin.left - 4, y + 3);
        }
        // Axis label
        ctx.save();
        ctx.translate(10, margin.top + plotH / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillText('g', 0, 0);
        ctx.restore();
    }

    // Right axis — Gyro (°/s) — tinted orange to match gyro color group
    if (hasGyro) {
        ctx.fillStyle = '#ccaa66';
        ctx.font = '10px monospace';
        ctx.textAlign = 'left';
        for (let i = 0; i <= gridLines; i++) {
            const val = gyroRange.max - (gyroRange.max - gyroRange.min) * i / gridLines;
            const y = margin.top + (plotH * i / gridLines);
            ctx.fillText(val.toFixed(1), w - margin.right + 4, y + 3);
        }
        // Axis label
        ctx.save();
        ctx.translate(w - 4, margin.top + plotH / 2);
        ctx.rotate(Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillText('\u00b0/s', 0, 0);
        ctx.restore();
    }

    // Time axis labels
    ctx.fillStyle = '#666';
    ctx.textAlign = 'center';
    const secVisible = dataCount / 100;
    for (let s = 0; s <= Math.min(secVisible, CHART_SECONDS); s += 5) {
        if (s === 0) continue;
        const x = margin.left + plotW - (s / secVisible) * plotW;
        if (x < margin.left) break;
        ctx.fillText('-' + s + 's', x, h - 4);
    }

    // Draw traces — each group uses its own Y scale
    ctx.lineWidth = 1.5;
    const allActive = [...activeAccel, ...activeGyro];
    for (const t of allActive) {
        const range = t.group === 'accel' ? accelRange : gyroRange;
        ctx.strokeStyle = t.color;
        ctx.beginPath();
        let started = false;
        for (let i = 0; i < nPoints; i++) {
            const di = (dataHead - dataCount + Math.floor(i * dataCount / nPoints) + MAX_POINTS) % MAX_POINTS;
            const val = data[t.key][di];
            const x = margin.left + (i / nPoints) * plotW;
            const y = margin.top + plotH - ((val - range.min) / (range.max - range.min)) * plotH;
            if (!started) { ctx.moveTo(x, y); started = true; }
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
    }

    requestAnimationFrame(drawChart);
}
requestAnimationFrame(drawChart);

// ===== Trace toggle buttons =====
const tcDiv = document.getElementById('trace-controls');
TRACES.forEach((t, i) => {
    const el = document.createElement('div');
    el.className = 'trace-toggle' + (t.on ? '' : ' off');
    el.innerHTML = `<span class="trace-swatch" style="background:${t.color}"></span>${t.label}`;
    el.onclick = () => {
        t.on = !t.on;
        el.className = 'trace-toggle' + (t.on ? '' : ' off');
    };
    tcDiv.appendChild(el);
});

// ===== Recording =====
function startRec() {
    recording = true;
    recSamples = [];
    recStart = Date.now();
    document.getElementById('btn-start').style.display = 'none';
    document.getElementById('btn-stop').style.display = 'inline-block';
    document.getElementById('btn-save').style.display = 'none';
    document.getElementById('rec-status').innerHTML =
        '<span class="status-dot dot-rec"></span><span id="rec-time">0:00</span>';

    // Send start command to ESP32
    if (ws && ws.readyState === 1) ws.send(new Uint8Array([0x10]));

    recTimer = setInterval(() => {
        const sec = Math.floor((Date.now() - recStart) / 1000);
        const m = Math.floor(sec / 60);
        const s = (sec % 60).toString().padStart(2, '0');
        document.getElementById('rec-time').textContent = m + ':' + s;
    }, 1000);
}

function stopRec() {
    recording = false;
    clearInterval(recTimer);
    document.getElementById('btn-start').style.display = 'inline-block';
    document.getElementById('btn-stop').style.display = 'none';
    document.getElementById('btn-save').style.display = 'inline-block';
    document.getElementById('rec-status').innerHTML = '';

    // Send stop command to ESP32
    if (ws && ws.readyState === 1) ws.send(new Uint8Array([0x11]));

    const dur = ((Date.now() - recStart) / 1000).toFixed(1);
    document.getElementById('rec-info').textContent =
        recSamples.length.toLocaleString() + ' samples, ' + dur + 's';

    // Refresh file list after recording stops (flash file was saved)
    setTimeout(() => { fetchSurveys(); fetchStatus(); }, 500);
}

function saveRec() {
    // Browser-side JSON save — works for long recordings that exceed flash capacity.
    // Captive portal webviews don't support Blob URLs, so we use a data URI
    // with octet-stream MIME type which triggers a download/share prompt.
    const survey = {
        version: 1,
        car: 'GeometryCar',
        start_time: new Date(recStart).toISOString(),
        duration_sec: (Date.now() - recStart) / 1000,
        sample_rate_hz: 100,
        accel_range_g: 2,
        gyro_range_dps: 250,
        samples: recSamples
    };
    const json = JSON.stringify(survey);
    const dataUri = 'data:application/octet-stream;charset=utf-8,' + encodeURIComponent(json);
    const a = document.createElement('a');
    a.href = dataUri;
    a.download = 'survey_' + new Date().toISOString().replace(/[:.]/g, '') + '.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

// ===== Flash Recording Status (WS 0x03) =====
function parseRecStatus(v) {
    // Frame: [type:1][recording:1][fnLen:1][filename:N][bytes:4][samples:4]
    const isRec = v.getUint8(1) === 1;
    const fnLen = v.getUint8(2);
    let filename = '';
    for (let i = 0; i < fnLen; i++) filename += String.fromCharCode(v.getUint8(3 + i));
    const bytes = v.getUint32(3 + fnLen, true);
    const samples = v.getUint32(3 + fnLen + 4, true);

    // Update flash recording indicator in status bar
    const recEl = document.getElementById('rec-status');
    if (isRec) {
        recEl.innerHTML = '<span class="status-dot dot-rec"></span>Flash REC';
    } else {
        recEl.innerHTML = '';
        // Recording stopped — refresh file list
        fetchSurveys();
        fetchStatus();
    }
}

// ===== File Manager =====
let fmOpen = false;

function toggleFileManager() {
    fmOpen = !fmOpen;
    document.getElementById('fm-body').className = fmOpen ? 'open' : '';
    document.getElementById('fm-toggle').innerHTML = fmOpen ? '&#9650;' : '&#9660;';
    if (fmOpen) {
        fetchSurveys();
        fetchStatus();
    }
}

function fetchStatus() {
    fetch('/api/status')
        .then(r => r.json())
        .then(st => {
            const used = st.flash_total - st.flash_free;
            const pct = st.flash_total > 0 ? (used / st.flash_total * 100) : 0;
            document.getElementById('flash-fill').style.width = pct.toFixed(1) + '%';
            const freeKB = (st.flash_free / 1024).toFixed(0);
            const totalKB = (st.flash_total / 1024).toFixed(0);
            document.getElementById('flash-info').textContent =
                'Flash: ' + freeKB + ' KB free / ' + totalKB + ' KB total (' +
                st.file_count + ' file' + (st.file_count !== 1 ? 's' : '') + ')';
        })
        .catch(() => {});
}

function fetchSurveys() {
    fetch('/api/surveys')
        .then(r => r.json())
        .then(surveys => {
            const list = document.getElementById('survey-list');
            if (surveys.length === 0) {
                list.innerHTML = '<div style="color:#555;font-size:11px;padding:4px 0">No saved surveys</div>';
                return;
            }
            list.innerHTML = '';
            surveys.forEach(s => {
                const div = document.createElement('div');
                div.className = 'survey-item';
                const sizeKB = (s.size / 1024).toFixed(1);
                const dur = s.duration_sec.toFixed(0);
                div.innerHTML =
                    '<span><span class="survey-name">' + s.name + '</span>' +
                    '<span class="survey-meta">' + sizeKB + ' KB, ' + dur + 's, ' +
                    s.samples + ' smp</span></span>' +
                    '<span class="survey-actions">' +
                    '<button class="btn-dl" onclick="dlSurvey(\'' + s.name + '\')">DL</button>' +
                    '<button class="btn-del" onclick="delSurvey(\'' + s.name + '\')">Del</button>' +
                    '</span>';
                list.appendChild(div);
            });
        })
        .catch(() => {});
}

function dlSurvey(name) {
    const a = document.createElement('a');
    a.href = '/api/survey/' + name;
    a.download = name;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

function delSurvey(name) {
    if (!confirm('Delete ' + name + '?')) return;
    fetch('/api/survey/' + name, { method: 'DELETE' })
        .then(r => {
            if (r.ok) {
                fetchSurveys();
                fetchStatus();
            }
        })
        .catch(() => {});
}

// ===== Init =====
wsConnect();
</script>
</body>
</html>
