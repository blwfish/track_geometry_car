<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Track Geometry Car</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
    background: #1a1a2e;
    color: #e0e0e0;
    font-family: 'Courier New', monospace;
    font-size: 14px;
    overflow-x: hidden;
}
#status-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 12px;
    background: #16213e;
    border-bottom: 1px solid #0f3460;
}
.status-dot {
    display: inline-block;
    width: 10px; height: 10px;
    border-radius: 50%;
    margin-right: 6px;
}
.dot-green { background: #4ade80; }
.dot-red { background: #ef4444; animation: pulse 1s infinite; }
.dot-rec { background: #ef4444; animation: pulse 0.5s infinite; }
@keyframes pulse { 50% { opacity: 0.4; } }
#chart-container {
    padding: 4px;
    position: relative;
}
canvas {
    width: 100%;
    height: 35vh;
    min-height: 180px;
    display: block;
    background: #0f0f23;
    border-radius: 4px;
}
#trace-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    padding: 6px 12px;
    justify-content: center;
}
.trace-toggle {
    display: flex;
    align-items: center;
    gap: 3px;
    padding: 4px 8px;
    border-radius: 4px;
    background: #16213e;
    cursor: pointer;
    font-size: 12px;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
}
.trace-toggle.off { opacity: 0.35; }
.trace-swatch {
    width: 12px; height: 12px;
    border-radius: 2px;
}
#readouts {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    padding: 8px 12px;
}
.readout-group {
    background: #16213e;
    border-radius: 4px;
    padding: 8px;
}
.readout-group h3 {
    font-size: 11px;
    color: #888;
    margin-bottom: 4px;
    font-weight: normal;
    text-transform: uppercase;
}
.readout-row {
    display: flex;
    justify-content: space-between;
    font-size: 13px;
    line-height: 1.6;
}
.readout-label { color: #888; }
.readout-val { color: #e0e0e0; text-align: right; }
#recording-bar {
    display: flex;
    gap: 8px;
    padding: 10px 12px;
    align-items: center;
    justify-content: center;
}
button {
    padding: 10px 20px;
    border: none;
    border-radius: 6px;
    font-family: inherit;
    font-size: 14px;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
}
#btn-start {
    background: #166534;
    color: #fff;
}
#btn-stop {
    background: #991b1b;
    color: #fff;
}
#btn-save {
    background: #1e40af;
    color: #fff;
}
#btn-cal { background: #1e3a5f; color: #8cb4e0; }
#btn-analyze { background: #4c1d95; color: #c4b5fd; }
#cal-msg { font-size: 12px; color: #fbbf24; display: none; }
button:disabled { opacity: 0.4; cursor: default; }
#rec-info {
    font-size: 12px;
    color: #888;
}
#file-manager {
    padding: 8px 12px;
}
#fm-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 6px 8px;
    background: #16213e;
    border-radius: 4px 4px 0 0;
    cursor: pointer;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
}
#fm-header h3 {
    font-size: 12px;
    font-weight: normal;
    color: #aaa;
    text-transform: uppercase;
}
#fm-toggle { color: #666; font-size: 12px; }
#fm-body {
    background: #121a30;
    border-radius: 0 0 4px 4px;
    padding: 6px 8px;
    display: none;
}
#fm-body.open { display: block; }
#flash-bar {
    height: 6px;
    background: #0a0f1e;
    border-radius: 3px;
    margin-bottom: 6px;
    overflow: hidden;
}
#flash-fill {
    height: 100%;
    background: #1e40af;
    border-radius: 3px;
    transition: width 0.3s;
}
#flash-info {
    font-size: 11px;
    color: #666;
    margin-bottom: 6px;
}
.survey-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 0;
    border-top: 1px solid #1a2a4a;
    font-size: 12px;
}
.survey-item:first-child { border-top: none; }
.survey-name { color: #aaa; }
.survey-meta { color: #666; margin-left: 8px; }
.survey-actions { display: flex; gap: 4px; }
.survey-actions button {
    padding: 3px 8px;
    font-size: 11px;
    border-radius: 3px;
}
.btn-dl { background: #1e3a5f; color: #8cb4e0; }
.btn-del { background: #3f1515; color: #e08c8c; }
#wifi-manager { padding: 8px 12px; }
#wm-header {
    display: flex; justify-content: space-between; align-items: center;
    padding: 6px 8px; background: #16213e; border-radius: 4px 4px 0 0;
    cursor: pointer; user-select: none; -webkit-tap-highlight-color: transparent;
}
#wm-header h3 { font-size: 12px; font-weight: normal; color: #aaa; text-transform: uppercase; }
#wm-toggle { color: #666; font-size: 12px; }
#wm-body { background: #121a30; border-radius: 0 0 4px 4px; padding: 6px 8px; display: none; }
#wm-body.open { display: block; }
#wifi-status { font-size: 12px; color: #aaa; margin-bottom: 8px; }
.wifi-net {
    display: flex; justify-content: space-between; align-items: center;
    padding: 6px 4px; border-top: 1px solid #1a2a4a; font-size: 12px; cursor: pointer;
}
.wifi-net:first-child { border-top: none; }
.wifi-net:active { background: #1a2a4a; }
.wifi-ssid { color: #e0e0e0; }
.wifi-meta { color: #666; font-size: 11px; }
#wifi-pass-row { display: none; padding: 8px 0; gap: 6px; align-items: center; }
#wifi-pass-row.show { display: flex; }
#wifi-pass-input {
    flex: 1; background: #0f0f23; color: #e0e0e0; border: 1px solid #333;
    border-radius: 4px; font-family: inherit; font-size: 13px; padding: 6px 8px;
}
.btn-scan { background: #1e3a5f; color: #8cb4e0; padding: 6px 12px; font-size: 12px; }
.btn-connect { background: #166534; color: #fff; padding: 6px 12px; font-size: 12px; }
.btn-forget { background: #991b1b; color: #fff; padding: 6px 12px; font-size: 12px; margin-top: 6px; }
#wifi-msg { font-size: 12px; color: #fbbf24; padding: 4px 0; display: none; }
#geom-group { border: 1px solid #1e3a5f; }
#speed-input:focus { outline: 1px solid #0f3460; }
#car-setup { padding: 8px 12px; }
#cs-header {
    display: flex; justify-content: space-between; align-items: center;
    padding: 6px 8px; background: #16213e; border-radius: 4px 4px 0 0;
    cursor: pointer; user-select: none; -webkit-tap-highlight-color: transparent;
}
#cs-header h3 { font-size: 12px; font-weight: normal; color: #aaa; text-transform: uppercase; }
#cs-toggle { color: #666; font-size: 12px; }
#cs-body { background: #121a30; border-radius: 0 0 4px 4px; padding: 8px; display: none; }
#cs-body.open { display: block; }
.cs-row {
    display: flex; align-items: center; gap: 6px;
    font-size: 12px; color: #aaa; padding: 3px 0;
}
.cs-row label { flex: 1; }
.cs-row input[type="number"] {
    width: 52px; background: #0f0f23; color: #e0e0e0; border: 1px solid #333;
    border-radius: 3px; font-family: inherit; font-size: 12px; text-align: right; padding: 2px 4px;
}
.cs-row input[type="number"]:focus { outline: 1px solid #0f3460; }
.cs-unit { font-size: 11px; color: #666; min-width: 24px; }
#btn-save-truck { background: #1e3a5f; color: #8cb4e0; padding: 6px 12px; font-size: 11px; margin-top: 6px; }
#cs-msg { font-size: 11px; color: #4ade80; display: none; margin-top: 4px; }
#analysis { padding: 8px 12px; display: none; }
#analysis.show { display: block; }
#an-header {
    display: flex; justify-content: space-between; align-items: center;
    padding: 6px 8px; background: #16213e; border-radius: 4px 4px 0 0;
    cursor: pointer; user-select: none; -webkit-tap-highlight-color: transparent;
}
#an-header h3 { font-size: 12px; font-weight: normal; color: #aaa; text-transform: uppercase; }
#an-toggle { color: #666; font-size: 12px; }
#an-body { background: #121a30; border-radius: 0 0 4px 4px; padding: 8px; display: none; }
#an-body.open { display: block; }
.an-chart { width: 100%; margin-bottom: 8px; border-radius: 4px; }
#an-path { height: 220px; }
#an-timeline { height: 160px; }
.an-label { font-size: 11px; color: #888; margin-bottom: 2px; }
#an-summary { font-size: 12px; color: #aaa; margin-bottom: 8px; line-height: 1.6; }
#an-summary b { color: #e0e0e0; }
.an-legend { font-size: 10px; color: #666; margin-bottom: 6px; }
@media (min-width: 601px) {
    canvas { height: 400px; min-height: 300px; }
    #readouts { grid-template-columns: 1fr 1fr 1fr; }
    #an-path { height: 280px; }
    #an-timeline { height: 200px; }
}
/* Landscape phone: taller chart, compact readouts */
@media (orientation: landscape) and (max-height: 500px) {
    canvas { height: 55vh; min-height: 150px; }
    #readouts { grid-template-columns: 1fr 1fr 1fr 1fr; gap: 4px; padding: 4px 8px; }
    .readout-group { padding: 4px 6px; }
    #recording-bar { padding: 4px 8px; }
    button { padding: 6px 14px; font-size: 12px; }
}
</style>
</head>
<body>

<div id="status-bar">
    <span id="conn-status"><span class="status-dot dot-red"></span>Connecting...</span>
    <span id="rec-status"></span>
</div>

<div id="chart-container">
    <canvas id="chart"></canvas>
</div>

<div id="trace-controls"></div>

<div id="readouts">
    <div class="readout-group">
        <h3>Accel RMS (g)</h3>
        <div class="readout-row"><span class="readout-label">X</span><span class="readout-val" id="ax-rms">-</span></div>
        <div class="readout-row"><span class="readout-label">Y</span><span class="readout-val" id="ay-rms">-</span></div>
        <div class="readout-row"><span class="readout-label">Z</span><span class="readout-val" id="az-rms">-</span></div>
    </div>
    <div class="readout-group">
        <h3>Accel Peak (g)</h3>
        <div class="readout-row"><span class="readout-label">X</span><span class="readout-val" id="ax-pk">-</span></div>
        <div class="readout-row"><span class="readout-label">Y</span><span class="readout-val" id="ay-pk">-</span></div>
        <div class="readout-row"><span class="readout-label">Z</span><span class="readout-val" id="az-pk">-</span></div>
    </div>
    <div class="readout-group">
        <h3>Gyro (°/s)</h3>
        <div class="readout-row"><span class="readout-label">X</span><span class="readout-val" id="gx-val">-</span></div>
        <div class="readout-row"><span class="readout-label">Y</span><span class="readout-val" id="gy-val">-</span></div>
        <div class="readout-row"><span class="readout-label">Z</span><span class="readout-val" id="gz-val">-</span></div>
    </div>
    <div class="readout-group">
        <h3>System</h3>
        <div class="readout-row"><span class="readout-label">Temp</span><span class="readout-val" id="temp-val">-</span></div>
        <div class="readout-row"><span class="readout-label">Rate</span><span class="readout-val" id="rate-val">-</span></div>
        <div class="readout-row"><span class="readout-label">Samples</span><span class="readout-val" id="count-val">-</span></div>
    </div>
    <div class="readout-group imu2-group" style="display:none">
        <h3>Accel2 RMS (g)</h3>
        <div class="readout-row"><span class="readout-label">X</span><span class="readout-val" id="ax2-rms">-</span></div>
        <div class="readout-row"><span class="readout-label">Y</span><span class="readout-val" id="ay2-rms">-</span></div>
        <div class="readout-row"><span class="readout-label">Z</span><span class="readout-val" id="az2-rms">-</span></div>
    </div>
    <div class="readout-group imu2-group" style="display:none">
        <h3>Accel2 Peak (g)</h3>
        <div class="readout-row"><span class="readout-label">X</span><span class="readout-val" id="ax2-pk">-</span></div>
        <div class="readout-row"><span class="readout-label">Y</span><span class="readout-val" id="ay2-pk">-</span></div>
        <div class="readout-row"><span class="readout-label">Z</span><span class="readout-val" id="az2-pk">-</span></div>
    </div>
    <div class="readout-group imu2-group" style="display:none">
        <h3>Gyro2 (°/s)</h3>
        <div class="readout-row"><span class="readout-label">X</span><span class="readout-val" id="gx2-val">-</span></div>
        <div class="readout-row"><span class="readout-label">Y</span><span class="readout-val" id="gy2-val">-</span></div>
        <div class="readout-row"><span class="readout-label">Z</span><span class="readout-val" id="gz2-val">-</span></div>
    </div>
    <div class="readout-group" id="geom-group">
        <h3>Geometry</h3>
        <div class="readout-row"><span class="readout-label">State</span><span class="readout-val" id="geom-state">-</span></div>
        <div class="readout-row"><span class="readout-label">Radius</span><span class="readout-val" id="geom-radius">-</span></div>
        <div class="readout-row"><span class="readout-label">Yaw</span><span class="readout-val" id="geom-yaw">-</span></div>
        <div class="readout-row"><span class="readout-label">Grade</span><span class="readout-val" id="geom-grade">-</span></div>
        <div class="readout-row"><span class="readout-label">SNR</span><span class="readout-val" id="geom-snr">-</span></div>
        <div class="readout-row"><span class="readout-label">Speed</span><span class="readout-val" id="geom-speed">-</span></div>
    </div>
</div>

<div id="recording-bar">
    <button id="btn-start" onclick="startRec()">Start Recording</button>
    <button id="btn-stop" style="display:none" onclick="stopRec()">Stop Recording</button>
    <button id="btn-save" style="display:none" onclick="saveRec()">Save Survey</button>
    <button id="btn-analyze" style="display:none" onclick="analyzeRec()">Analyze</button>
    <button id="btn-cal" onclick="calibrateGyro()">Calibrate</button>
    <span id="rec-info"></span>
    <span id="cal-msg"></span>
</div>

<div id="car-setup">
    <div id="cs-header" onclick="toggleCarSetup()">
        <h3>Car Setup</h3>
        <span id="cs-toggle">&#9660;</span>
    </div>
    <div id="cs-body">
        <div class="cs-row">
            <label>Speed</label>
            <input type="number" id="speed-input" value="10" min="1" max="60" step="1">
            <span class="cs-unit">mph</span>
        </div>
        <div class="cs-row">
            <label>Axles per truck</label>
            <input type="number" id="cs-axles" value="2" min="1" max="4" step="1">
            <span class="cs-unit"></span>
        </div>
        <div class="cs-row">
            <label>Axle spacing</label>
            <input type="number" id="cs-axle-sp" value="16.5" min="1" max="200" step="0.1">
            <span class="cs-unit">mm</span>
        </div>
        <div class="cs-row">
            <label>Truck spacing</label>
            <input type="number" id="cs-truck-sp" value="54" min="1" max="200" step="0.1">
            <span class="cs-unit">mm</span>
        </div>
        <button id="btn-save-truck" onclick="saveTruckConfig()">Save to Car</button>
        <div id="cs-msg">Saved</div>
    </div>
</div>

<div id="analysis">
    <div id="an-header" onclick="toggleAnalysis()">
        <h3>Recording Analysis</h3>
        <span id="an-toggle">&#9660;</span>
    </div>
    <div id="an-body">
        <div id="an-summary"></div>
        <div class="an-label">Track Plan View (integrated heading)</div>
        <div class="an-legend">
            <span style="color:#4488ff">&#9608; Outbound</span> &nbsp;
            <span style="color:#fbbf24">&#9608; Return</span> &nbsp;
            <span style="color:#888">&#9679; 5s ticks</span>
        </div>
        <canvas class="an-chart" id="an-path"></canvas>
        <div class="an-label">Accelerometer Timeline</div>
        <div class="an-legend">
            <span style="color:#4488ff">&#9472; Vertical (az)</span> &nbsp;
            <span style="color:#44ff88">&#9472; Lateral (ay)</span> &nbsp;
            <span style="color:#ef4444">&#9632; Bump/Joint</span> &nbsp;
            <span style="color:#f97316">&#9632; Kick/Kink</span>
        </div>
        <canvas class="an-chart" id="an-timeline"></canvas>
    </div>
</div>

<div id="file-manager">
    <div id="fm-header" onclick="toggleFileManager()">
        <h3>Saved Surveys</h3>
        <span id="fm-toggle">&#9660;</span>
    </div>
    <div id="fm-body">
        <div id="flash-bar"><div id="flash-fill" style="width:0%"></div></div>
        <div id="flash-info">Flash: --</div>
        <div id="survey-list"></div>
    </div>
</div>

<div id="wifi-manager">
    <div id="wm-header" onclick="toggleWifiManager()">
        <h3>WiFi Settings</h3>
        <span id="wm-toggle">&#9660;</span>
    </div>
    <div id="wm-body">
        <div id="wifi-status">Loading...</div>
        <button class="btn-scan" onclick="wifiScan()">Scan Networks</button>
        <div id="wifi-networks"></div>
        <div id="wifi-pass-row">
            <input type="password" id="wifi-pass-input" placeholder="Password">
            <button class="btn-connect" onclick="wifiConnect()">Connect</button>
        </div>
        <div id="wifi-msg"></div>
        <button class="btn-forget" id="btn-forget" style="display:none" onclick="wifiForget()">Forget Network</button>
    </div>
</div>

<script>
// ===== Configuration =====
const ACCEL_SCALE = 16384.0;
const GYRO_SCALE = 131.0;
const TEMP_SCALE = 340.0;
const TEMP_OFFSET = 36.53;
const CHART_SECONDS = 30;
const MAX_POINTS = CHART_SECONDS * 100;
const GYRO_NOISE_DPS = 0.05;  // MPU-6050 noise floor
const CURVE_THRESHOLD_DPS = 0.3;  // Below this = straight

// ===== Trace definitions =====
const TRACES = [
    { key: 'ax', label: 'aX', color: '#ff4444', group: 'accel', on: true },
    { key: 'ay', label: 'aY', color: '#44ff44', group: 'accel', on: true },
    { key: 'az', label: 'aZ', color: '#4488ff', group: 'accel', on: true },
    { key: 'gx', label: 'gX', color: '#ffaa44', group: 'gyro', on: true },
    { key: 'gy', label: 'gY', color: '#aa44ff', group: 'gyro', on: true },
    { key: 'gz', label: 'gZ', color: '#44ffff', group: 'gyro', on: true },
    // IMU #2 traces — dashed style, dimmer colors, hidden by default
    { key: 'ax2', label: 'aX2', color: '#cc2222', group: 'accel', on: false, imu2: true },
    { key: 'ay2', label: 'aY2', color: '#22cc22', group: 'accel', on: false, imu2: true },
    { key: 'az2', label: 'aZ2', color: '#2266cc', group: 'accel', on: false, imu2: true },
    { key: 'gx2', label: 'gX2', color: '#cc8822', group: 'gyro', on: false, imu2: true },
    { key: 'gy2', label: 'gY2', color: '#8822cc', group: 'gyro', on: false, imu2: true },
    { key: 'gz2', label: 'gZ2', color: '#22cccc', group: 'gyro', on: false, imu2: true },
];
let dualImuDetected = false;  // set true when non-zero IMU2 data arrives

// ===== Data store (circular typed arrays) =====
const data = {};
TRACES.forEach(t => data[t.key] = new Float32Array(MAX_POINTS));
let dataHead = 0, dataCount = 0;

// ===== Recording state =====
let recording = false;
let recSamples = [];
let recStart = 0;
let recTimer = null;

// Show IMU2 UI elements when dual IMU is detected
function showImu2UI() {
    document.querySelectorAll('.imu2-group').forEach(el => el.style.display = '');
    // Enable IMU2 trace toggle buttons
    document.querySelectorAll('.trace-toggle.imu2').forEach(el => el.style.display = '');
}

// ===== WebSocket =====
let ws = null;
let reconnectTimer = null;

function wsConnect() {
    const url = 'ws://' + location.host + '/ws';
    ws = new WebSocket(url);
    ws.binaryType = 'arraybuffer';

    ws.onopen = () => {
        document.getElementById('conn-status').innerHTML =
            '<span class="status-dot dot-green"></span>Connected';
        if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
        // Fetch flash status and config on connect
        fetchStatus();
        fetchSurveys();
        fetchTruckConfig();
    };

    ws.onclose = () => {
        document.getElementById('conn-status').innerHTML =
            '<span class="status-dot dot-red"></span>Disconnected';
        reconnectTimer = setTimeout(wsConnect, 2000);
    };

    ws.onerror = () => ws.close();
    ws.onmessage = (ev) => parseFrame(ev.data);
}

function parseFrame(buf) {
    const v = new DataView(buf);
    const type = v.getUint8(0);

    if (type === 0x01) {
        // Raw sample batch — 30 bytes per sample (dual IMU format)
        const count = v.getUint8(1);
        for (let i = 0; i < count; i++) {
            const o = 2 + i * 30;
            const s = {
                ts: v.getUint32(o, true),
                ax: v.getInt16(o + 4, true) / ACCEL_SCALE,
                ay: v.getInt16(o + 6, true) / ACCEL_SCALE,
                az: v.getInt16(o + 8, true) / ACCEL_SCALE,
                gx: v.getInt16(o + 10, true) / GYRO_SCALE,
                gy: v.getInt16(o + 12, true) / GYRO_SCALE,
                gz: v.getInt16(o + 14, true) / GYRO_SCALE,
                temp: v.getInt16(o + 16, true) / TEMP_SCALE + TEMP_OFFSET,
                // IMU #2 (zero when single-IMU)
                ax2: v.getInt16(o + 18, true) / ACCEL_SCALE,
                ay2: v.getInt16(o + 20, true) / ACCEL_SCALE,
                az2: v.getInt16(o + 22, true) / ACCEL_SCALE,
                gx2: v.getInt16(o + 24, true) / GYRO_SCALE,
                gy2: v.getInt16(o + 26, true) / GYRO_SCALE,
                gz2: v.getInt16(o + 28, true) / GYRO_SCALE,
            };
            // Detect dual IMU: if any IMU2 field is non-zero
            if (!dualImuDetected && (s.ax2 || s.ay2 || s.az2 || s.gx2 || s.gy2 || s.gz2)) {
                dualImuDetected = true;
                showImu2UI();
            }
            addSample(s);
            if (recording) recSamples.push(s);
        }
    } else if (type === 0x02) {
        // 1-second summary
        parseSummary(v);
    } else if (type === 0x03) {
        // Recording status notification from ESP32
        parseRecStatus(v);
    }
}

function addSample(s) {
    const idx = dataHead;
    TRACES.forEach(t => data[t.key][idx] = s[t.key]);
    dataHead = (dataHead + 1) % MAX_POINTS;
    if (dataCount < MAX_POINTS) dataCount++;
}

function parseSummary(v) {
    // summary_1s_t layout: timestamp(4) + 13 floats(52) + sample_count(4) + sample_rate(4)
    // + 12 IMU2 floats(48)
    // Byte 0 is frame type (0x02), data starts at byte 1
    let o = 1;
    const f = () => { const val = v.getFloat32(o, true); o += 4; return val; };
    const u = () => { const val = v.getUint32(o, true); o += 4; return val; };

    u(); // timestamp_ms — skip
    const axRms = f(), ayRms = f(), azRms = f();
    const axPk = f(), ayPk = f(), azPk = f();
    const gxRms = f(), gyRms = f(), gzRms = f();
    const gxMean = f(), gyMean = f(), gzMean = f();
    const temp = f();
    const count = u();
    const rate = f();

    // IMU #2 summary fields
    const ax2Rms = f(), ay2Rms = f(), az2Rms = f();
    const ax2Pk = f(), ay2Pk = f(), az2Pk = f();
    const gx2Rms = f(), gy2Rms = f(), gz2Rms = f();
    const gx2Mean = f(), gy2Mean = f(), gz2Mean = f();
    // Accel means (appended fields for grade computation)
    const axMean = f(), ayMean = f(), azMean = f();

    document.getElementById('ax-rms').textContent = axRms.toFixed(4);
    document.getElementById('ay-rms').textContent = ayRms.toFixed(4);
    document.getElementById('az-rms').textContent = azRms.toFixed(4);
    document.getElementById('ax-pk').textContent = axPk.toFixed(4);
    document.getElementById('ay-pk').textContent = ayPk.toFixed(4);
    document.getElementById('az-pk').textContent = azPk.toFixed(4);
    document.getElementById('gx-val').textContent = gxRms.toFixed(2);
    document.getElementById('gy-val').textContent = gyRms.toFixed(2);
    document.getElementById('gz-val').textContent = gzRms.toFixed(2);
    document.getElementById('temp-val').textContent = temp.toFixed(1) + '°C';
    document.getElementById('count-val').textContent = count.toLocaleString();
    document.getElementById('rate-val').textContent = rate.toFixed(1) + ' Hz';

    // IMU #2 readouts (only visible when dual IMU detected)
    if (dualImuDetected) {
        document.getElementById('ax2-rms').textContent = ax2Rms.toFixed(4);
        document.getElementById('ay2-rms').textContent = ay2Rms.toFixed(4);
        document.getElementById('az2-rms').textContent = az2Rms.toFixed(4);
        document.getElementById('ax2-pk').textContent = ax2Pk.toFixed(4);
        document.getElementById('ay2-pk').textContent = ay2Pk.toFixed(4);
        document.getElementById('az2-pk').textContent = az2Pk.toFixed(4);
        document.getElementById('gx2-val').textContent = gx2Rms.toFixed(2);
        document.getElementById('gy2-val').textContent = gy2Rms.toFixed(2);
        document.getElementById('gz2-val').textContent = gz2Rms.toFixed(2);
    }

    // Geometry computation from 1-second mean yaw rate and accel means
    updateGeometry(gzMean, azRms, axMean, ayMean, azMean);
}

function updateGeometry(yawMeanDps, azRms, axMean, ayMean, azMean) {
    const absYaw = Math.abs(yawMeanDps);
    const snr = absYaw / GYRO_NOISE_DPS;
    const speedMph = parseFloat(document.getElementById('speed-input').value) || 10;
    document.getElementById('geom-speed').textContent = speedMph + ' mph';
    // Convert scale mph to model mm/s (HO = 1:87)
    const speedMms = speedMph * 447.04 / 87.0;  // mph to mm/s prototype, then /87

    const stateEl = document.getElementById('geom-state');
    const radiusEl = document.getElementById('geom-radius');
    const yawEl = document.getElementById('geom-yaw');
    const snrEl = document.getElementById('geom-snr');
    const gradeEl = document.getElementById('geom-grade');

    yawEl.textContent = absYaw.toFixed(2) + ' \u00b0/s';
    snrEl.textContent = snr.toFixed(0);

    // Grade from longitudinal tilt: atan2(ax, az) gives pitch angle
    // On level track ax≈0, az≈1g. Positive ax = uphill (nose up).
    // Grade % = tan(pitch) * 100 = (ax/az) * 100
    if (axMean !== undefined && azMean !== undefined && azMean !== 0) {
        const gradePct = (axMean / azMean) * 100;
        const absGrade = Math.abs(gradePct);
        if (absGrade < 0.1) {
            gradeEl.textContent = 'Level';
            gradeEl.style.color = '#4ade80';
        } else {
            const dir = gradePct > 0 ? '\u2191' : '\u2193';  // ↑ uphill, ↓ downhill
            gradeEl.textContent = dir + ' ' + absGrade.toFixed(1) + '%';
            gradeEl.style.color = absGrade > 2 ? '#fbbf24' : '#e0e0e0';
        }
    }

    if (absYaw < CURVE_THRESHOLD_DPS) {
        // Straight track
        stateEl.textContent = 'Straight';
        stateEl.style.color = '#4ade80';
        radiusEl.textContent = '-';
        radiusEl.style.color = '#e0e0e0';
        snrEl.style.color = '#888';

        // Ride quality from vertical accel RMS
        if (azRms < 1.01) {
            stateEl.textContent = 'Straight \u2022 Smooth';
        } else if (azRms < 1.03) {
            stateEl.textContent = 'Straight \u2022 Fair';
        } else {
            stateEl.textContent = 'Straight \u2022 Rough';
            stateEl.style.color = '#fbbf24';
        }
    } else {
        // In a curve
        const yawRad = absYaw * Math.PI / 180;
        const radiusMm = speedMms / yawRad;
        const radiusIn = radiusMm / 25.4;
        const dir = yawMeanDps > 0 ? 'L' : 'R';

        stateEl.textContent = 'Curve ' + dir;
        stateEl.style.color = '#60a5fa';

        if (radiusIn < 100) {
            radiusEl.textContent = radiusIn.toFixed(1) + '"';
        } else {
            radiusEl.textContent = radiusIn.toFixed(0) + '"';
        }

        // Color code SNR: green=good, yellow=marginal, red=noisy
        if (snr >= 20) {
            snrEl.style.color = '#4ade80';
            radiusEl.style.color = '#e0e0e0';
        } else if (snr >= 10) {
            snrEl.style.color = '#fbbf24';
            radiusEl.style.color = '#fbbf24';
        } else {
            snrEl.style.color = '#ef4444';
            radiusEl.style.color = '#ef4444';
        }
    }
}

// ===== Strip Chart =====
const canvas = document.getElementById('chart');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * (window.devicePixelRatio || 1);
    canvas.height = rect.height * (window.devicePixelRatio || 1);
    ctx.scale(window.devicePixelRatio || 1, window.devicePixelRatio || 1);
}
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 150));
resizeCanvas();

// Smoothed range state — expand instantly, contract slowly to avoid axis flicker
const smoothRange = {
    accel: { min: null, max: null },
    gyro:  { min: null, max: null }
};
const RANGE_DECAY = 0.03;  // Per-frame contraction rate (~1s at 60fps)

function findRange(traces, nPoints, group) {
    let yMin = Infinity, yMax = -Infinity;
    for (const t of traces) {
        for (let i = 0; i < nPoints; i++) {
            const di = (dataHead - dataCount + Math.floor(i * dataCount / nPoints) + MAX_POINTS) % MAX_POINTS;
            const val = data[t.key][di];
            if (val < yMin) yMin = val;
            if (val > yMax) yMax = val;
        }
    }
    const rawRange = yMax - yMin || 0.01;
    const padded = { min: yMin - rawRange * 0.1, max: yMax + rawRange * 0.1 };

    // Apply smoothing: expand instantly, contract slowly
    const sr = smoothRange[group];
    if (sr.min === null) {
        sr.min = padded.min;
        sr.max = padded.max;
    } else {
        // Expand instantly
        if (padded.min < sr.min) sr.min = padded.min;
        if (padded.max > sr.max) sr.max = padded.max;
        // Contract slowly toward data range
        sr.min += (padded.min - sr.min) * RANGE_DECAY;
        sr.max += (padded.max - sr.max) * RANGE_DECAY;
    }

    return { min: sr.min, max: sr.max };
}

function drawChart() {
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;

    const activeAccel = TRACES.filter(t => t.on && t.group === 'accel');
    const activeGyro = TRACES.filter(t => t.on && t.group === 'gyro');
    const hasAccel = activeAccel.length > 0;
    const hasGyro = activeGyro.length > 0;

    // Adjust margins: right margin grows when gyro axis is visible
    const margin = { top: 10, right: hasGyro ? 50 : 10, bottom: 20, left: hasAccel ? 50 : 10 };
    // If only gyro is active, shrink left; if only accel, shrink right
    if (!hasAccel && hasGyro) margin.left = 10;
    if (hasAccel && !hasGyro) margin.right = 10;
    const plotW = w - margin.left - margin.right;
    const plotH = h - margin.top - margin.bottom;

    ctx.clearRect(0, 0, w, h);

    if (dataCount < 2) {
        ctx.fillStyle = '#444';
        ctx.font = '14px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('Waiting for data...', w / 2, h / 2);
        requestAnimationFrame(drawChart);
        return;
    }

    if (!hasAccel && !hasGyro) {
        requestAnimationFrame(drawChart);
        return;
    }

    const nPoints = Math.min(dataCount, Math.ceil(plotW));
    const gridLines = 5;

    // Compute independent ranges (with smoothing to prevent axis flicker)
    const accelRange = hasAccel ? findRange(activeAccel, nPoints, 'accel') : null;
    const gyroRange = hasGyro ? findRange(activeGyro, nPoints, 'gyro') : null;

    // Draw grid
    ctx.strokeStyle = '#1a2a4a';
    ctx.lineWidth = 1;
    for (let i = 0; i <= gridLines; i++) {
        const y = margin.top + (plotH * i / gridLines);
        ctx.beginPath();
        ctx.moveTo(margin.left, y);
        ctx.lineTo(w - margin.right, y);
        ctx.stroke();
    }

    // Left axis — Accel (g) — tinted blue to match accel color group
    if (hasAccel) {
        ctx.fillStyle = '#6688cc';
        ctx.font = '10px monospace';
        ctx.textAlign = 'right';
        for (let i = 0; i <= gridLines; i++) {
            const val = accelRange.max - (accelRange.max - accelRange.min) * i / gridLines;
            const y = margin.top + (plotH * i / gridLines);
            ctx.fillText(val.toFixed(3), margin.left - 4, y + 3);
        }
        // Axis label
        ctx.save();
        ctx.translate(10, margin.top + plotH / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillText('g', 0, 0);
        ctx.restore();
    }

    // Right axis — Gyro (°/s) — tinted orange to match gyro color group
    if (hasGyro) {
        ctx.fillStyle = '#ccaa66';
        ctx.font = '10px monospace';
        ctx.textAlign = 'left';
        for (let i = 0; i <= gridLines; i++) {
            const val = gyroRange.max - (gyroRange.max - gyroRange.min) * i / gridLines;
            const y = margin.top + (plotH * i / gridLines);
            ctx.fillText(val.toFixed(1), w - margin.right + 4, y + 3);
        }
        // Axis label
        ctx.save();
        ctx.translate(w - 4, margin.top + plotH / 2);
        ctx.rotate(Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillText('\u00b0/s', 0, 0);
        ctx.restore();
    }

    // Time axis labels
    ctx.fillStyle = '#666';
    ctx.textAlign = 'center';
    const secVisible = dataCount / 100;
    for (let s = 0; s <= Math.min(secVisible, CHART_SECONDS); s += 5) {
        if (s === 0) continue;
        const x = margin.left + plotW - (s / secVisible) * plotW;
        if (x < margin.left) break;
        ctx.fillText('-' + s + 's', x, h - 4);
    }

    // Draw traces — each group uses its own Y scale
    ctx.lineWidth = 1.5;
    const allActive = [...activeAccel, ...activeGyro];
    for (const t of allActive) {
        const range = t.group === 'accel' ? accelRange : gyroRange;
        ctx.strokeStyle = t.color;
        // IMU2 traces use dashed lines to distinguish from IMU1
        if (t.imu2) ctx.setLineDash([4, 3]);
        else ctx.setLineDash([]);
        ctx.beginPath();
        let started = false;
        for (let i = 0; i < nPoints; i++) {
            const di = (dataHead - dataCount + Math.floor(i * dataCount / nPoints) + MAX_POINTS) % MAX_POINTS;
            const val = data[t.key][di];
            const x = margin.left + (i / nPoints) * plotW;
            const y = margin.top + plotH - ((val - range.min) / (range.max - range.min)) * plotH;
            if (!started) { ctx.moveTo(x, y); started = true; }
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
    }
    ctx.setLineDash([]);  // reset

    requestAnimationFrame(drawChart);
}
requestAnimationFrame(drawChart);

// ===== Trace toggle buttons =====
const tcDiv = document.getElementById('trace-controls');
TRACES.forEach((t, i) => {
    const el = document.createElement('div');
    el.className = 'trace-toggle' + (t.on ? '' : ' off') + (t.imu2 ? ' imu2' : '');
    if (t.imu2) el.style.display = 'none';  // hidden until dual IMU detected
    el.innerHTML = `<span class="trace-swatch" style="background:${t.color}"></span>${t.label}`;
    el.onclick = () => {
        t.on = !t.on;
        el.className = 'trace-toggle' + (t.on ? '' : ' off') + (t.imu2 ? ' imu2' : '');
        // Reset range smoothing for this group so scale adapts immediately
        smoothRange[t.group].min = null;
        smoothRange[t.group].max = null;
    };
    tcDiv.appendChild(el);
});

// ===== Recording =====
function startRec() {
    recording = true;
    recSamples = [];
    recStart = Date.now();
    document.getElementById('btn-start').style.display = 'none';
    document.getElementById('btn-stop').style.display = 'inline-block';
    document.getElementById('btn-save').style.display = 'none';
    document.getElementById('btn-analyze').style.display = 'none';
    document.getElementById('analysis').className = '';
    document.getElementById('rec-status').innerHTML =
        '<span class="status-dot dot-rec"></span><span id="rec-time">0:00</span>';

    // Send start command to ESP32
    if (ws && ws.readyState === 1) ws.send(new Uint8Array([0x10]));

    recTimer = setInterval(() => {
        const sec = Math.floor((Date.now() - recStart) / 1000);
        const m = Math.floor(sec / 60);
        const s = (sec % 60).toString().padStart(2, '0');
        document.getElementById('rec-time').textContent = m + ':' + s;
    }, 1000);
}

function stopRec() {
    recording = false;
    clearInterval(recTimer);
    document.getElementById('btn-start').style.display = 'inline-block';
    document.getElementById('btn-stop').style.display = 'none';
    document.getElementById('btn-save').style.display = 'inline-block';
    document.getElementById('btn-analyze').style.display = 'inline-block';
    document.getElementById('rec-status').innerHTML = '';

    // Send stop command to ESP32
    if (ws && ws.readyState === 1) ws.send(new Uint8Array([0x11]));

    const dur = ((Date.now() - recStart) / 1000).toFixed(1);
    document.getElementById('rec-info').textContent =
        recSamples.length.toLocaleString() + ' samples, ' + dur + 's';

    // Refresh file list after recording stops (flash file was saved)
    setTimeout(() => { fetchSurveys(); fetchStatus(); }, 500);
}

function saveRec() {
    // Browser-side JSON save — works for long recordings that exceed flash capacity.
    // Captive portal webviews don't support Blob URLs, so we use a data URI
    // with octet-stream MIME type which triggers a download/share prompt.
    const defaultName = 'survey_' + new Date().toISOString().replace(/[:.]/g, '').slice(0, 15);
    const name = prompt('Survey name:', defaultName);
    if (name === null) return;  // user cancelled
    const filename = (name.trim() || defaultName) + '.json';

    const truckCfg = getTruckConfig();
    const survey = {
        version: dualImuDetected ? 2 : 1,
        imu_count: dualImuDetected ? 2 : 1,
        car: 'GeometryCar',
        name: name.trim() || defaultName,
        start_time: new Date(recStart).toISOString(),
        duration_sec: (Date.now() - recStart) / 1000,
        sample_rate_hz: 100,
        accel_range_g: 2,
        gyro_range_dps: 250,
        speed_mph: parseFloat(document.getElementById('speed-input').value) || 10,
        truck: {
            axles_per_truck: truckCfg.axles,
            axle_spacing_mm: truckCfg.axleSpacingMm,
            truck_spacing_mm: truckCfg.truckSpacingMm
        },
        samples: recSamples
    };
    const json = JSON.stringify(survey);
    const dataUri = 'data:application/octet-stream;charset=utf-8,' + encodeURIComponent(json);
    const a = document.createElement('a');
    a.href = dataUri;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

// ===== Flash Recording Status (WS 0x03) =====
function parseRecStatus(v) {
    // Frame: [type:1][recording:1][fnLen:1][filename:N][bytes:4][samples:4]
    const isRec = v.getUint8(1) === 1;
    const fnLen = v.getUint8(2);
    let filename = '';
    for (let i = 0; i < fnLen; i++) filename += String.fromCharCode(v.getUint8(3 + i));
    const bytes = v.getUint32(3 + fnLen, true);
    const samples = v.getUint32(3 + fnLen + 4, true);

    // Update flash recording indicator in status bar
    const recEl = document.getElementById('rec-status');
    if (isRec) {
        recEl.innerHTML = '<span class="status-dot dot-rec"></span>Flash REC';
    } else {
        recEl.innerHTML = '';
        // Recording stopped — refresh file list
        fetchSurveys();
        fetchStatus();
    }
}

// ===== File Manager =====
let fmOpen = false;

// ===== Car Setup =====
let csOpen = false;

function toggleCarSetup() {
    csOpen = !csOpen;
    document.getElementById('cs-body').className = csOpen ? 'open' : '';
    document.getElementById('cs-toggle').innerHTML = csOpen ? '&#9650;' : '&#9660;';
}

function fetchTruckConfig() {
    fetch('/api/config/truck')
        .then(r => r.json())
        .then(cfg => {
            document.getElementById('cs-axles').value = cfg.axles;
            document.getElementById('cs-axle-sp').value = cfg.axle_spacing_mm;
            document.getElementById('cs-truck-sp').value = cfg.truck_spacing_mm;
        })
        .catch(() => {});  // use defaults in HTML if fetch fails
}

function saveTruckConfig() {
    const cfg = {
        axles: parseInt(document.getElementById('cs-axles').value) || 2,
        axle_spacing_mm: parseFloat(document.getElementById('cs-axle-sp').value) || 16.5,
        truck_spacing_mm: parseFloat(document.getElementById('cs-truck-sp').value) || 54.0
    };
    fetch('/api/config/truck', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(cfg)
    }).then(r => {
        if (r.ok) {
            const msg = document.getElementById('cs-msg');
            msg.style.display = 'block';
            setTimeout(() => msg.style.display = 'none', 2000);
        }
    }).catch(() => {});
}

function getTruckConfig() {
    return {
        axles: parseInt(document.getElementById('cs-axles').value) || 2,
        axleSpacingMm: parseFloat(document.getElementById('cs-axle-sp').value) || 16.5,
        truckSpacingMm: parseFloat(document.getElementById('cs-truck-sp').value) || 54.0
    };
}

function toggleFileManager() {
    fmOpen = !fmOpen;
    document.getElementById('fm-body').className = fmOpen ? 'open' : '';
    document.getElementById('fm-toggle').innerHTML = fmOpen ? '&#9650;' : '&#9660;';
    if (fmOpen) {
        fetchSurveys();
        fetchStatus();
    }
}

function fetchStatus() {
    fetch('/api/status')
        .then(r => r.json())
        .then(st => {
            const used = st.flash_total - st.flash_free;
            const pct = st.flash_total > 0 ? (used / st.flash_total * 100) : 0;
            document.getElementById('flash-fill').style.width = pct.toFixed(1) + '%';
            const freeKB = (st.flash_free / 1024).toFixed(0);
            const totalKB = (st.flash_total / 1024).toFixed(0);
            document.getElementById('flash-info').textContent =
                'Flash: ' + freeKB + ' KB free / ' + totalKB + ' KB total (' +
                st.file_count + ' file' + (st.file_count !== 1 ? 's' : '') + ')';
        })
        .catch(() => {});
}

function fetchSurveys() {
    fetch('/api/surveys')
        .then(r => r.json())
        .then(surveys => {
            const list = document.getElementById('survey-list');
            if (surveys.length === 0) {
                list.innerHTML = '<div style="color:#555;font-size:11px;padding:4px 0">No saved surveys</div>';
                return;
            }
            list.innerHTML = '';
            surveys.forEach(s => {
                const div = document.createElement('div');
                div.className = 'survey-item';
                const sizeKB = (s.size / 1024).toFixed(1);
                const dur = s.duration_sec.toFixed(0);
                div.innerHTML =
                    '<span><span class="survey-name">' + s.name + '</span>' +
                    '<span class="survey-meta">' + sizeKB + ' KB, ' + dur + 's, ' +
                    s.samples + ' smp</span></span>' +
                    '<span class="survey-actions">' +
                    '<button class="btn-dl" onclick="dlSurvey(\'' + s.name + '\')">DL</button>' +
                    '<button class="btn-del" onclick="delSurvey(\'' + s.name + '\')">Del</button>' +
                    '</span>';
                list.appendChild(div);
            });
        })
        .catch(() => {});
}

function dlSurvey(name) {
    const a = document.createElement('a');
    a.href = '/api/survey/' + name;
    a.download = name;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

function delSurvey(name) {
    if (!confirm('Delete ' + name + '?')) return;
    fetch('/api/survey/' + name, { method: 'DELETE' })
        .then(r => {
            if (r.ok) {
                fetchSurveys();
                fetchStatus();
            }
        })
        .catch(() => {});
}

// ===== WiFi Settings =====
let wmOpen = false;
let selectedSSID = '';

function toggleWifiManager() {
    wmOpen = !wmOpen;
    document.getElementById('wm-body').className = wmOpen ? 'open' : '';
    document.getElementById('wm-toggle').innerHTML = wmOpen ? '&#9650;' : '&#9660;';
    if (wmOpen) fetchWifiStatus();
}

function fetchWifiStatus() {
    fetch('/api/wifi/status')
        .then(r => r.json())
        .then(st => {
            const el = document.getElementById('wifi-status');
            const mode = st.mode === 'sta' ? 'Station' : 'Access Point';
            let html = 'Mode: <b style="color:#60a5fa">' + mode + '</b>';
            html += ' &middot; SSID: <b style="color:#e0e0e0">' + st.ssid + '</b>';
            html += ' &middot; IP: ' + st.ip;
            if (st.mode === 'sta') {
                html += ' &middot; RSSI: ' + st.rssi + ' dBm';
            }
            el.innerHTML = html;

            // Show/hide forget button
            document.getElementById('btn-forget').style.display =
                st.mode === 'sta' ? 'inline-block' : 'none';
        })
        .catch(() => {
            document.getElementById('wifi-status').textContent = 'Failed to load WiFi status';
        });
}

function wifiScan() {
    const btn = document.querySelector('.btn-scan');
    btn.disabled = true;
    btn.textContent = 'Scanning...';
    document.getElementById('wifi-networks').innerHTML = '';

    function pollScan() {
        fetch('/api/wifi/scan')
            .then(r => r.json())
            .then(result => {
                if (result.status === 'scanning') {
                    setTimeout(pollScan, 1000);
                    return;
                }
                // result is the array of networks
                btn.disabled = false;
                btn.textContent = 'Scan Networks';
                showScanResults(result);
            })
            .catch(() => {
                btn.disabled = false;
                btn.textContent = 'Scan Networks';
            });
    }
    pollScan();
}

function rssiToSignal(rssi) {
    if (rssi >= -50) return '\u2588\u2587\u2586\u2585';
    if (rssi >= -60) return '\u2588\u2587\u2586\u2581';
    if (rssi >= -70) return '\u2588\u2587\u2581\u2581';
    return '\u2588\u2581\u2581\u2581';
}

function showScanResults(networks) {
    const el = document.getElementById('wifi-networks');
    if (!networks || networks.length === 0) {
        el.innerHTML = '<div style="color:#555;font-size:11px;padding:4px 0">No networks found</div>';
        return;
    }
    // Sort by signal strength
    networks.sort((a, b) => b.rssi - a.rssi);
    el.innerHTML = '';
    networks.forEach(n => {
        const div = document.createElement('div');
        div.className = 'wifi-net';
        const lock = n.open ? '' : '\uD83D\uDD12';
        div.innerHTML = '<span class="wifi-ssid">' + lock + ' ' + n.ssid + '</span>' +
            '<span class="wifi-meta">' + rssiToSignal(n.rssi) + ' ' + n.rssi + 'dB</span>';
        div.onclick = () => selectNetwork(n.ssid, n.open);
        el.appendChild(div);
    });
}

function selectNetwork(ssid, isOpen) {
    selectedSSID = ssid;
    const passRow = document.getElementById('wifi-pass-row');
    if (isOpen) {
        passRow.className = '';
        // Connect immediately for open networks
        wifiConnect();
    } else {
        passRow.className = 'show';
        document.getElementById('wifi-pass-input').value = '';
        document.getElementById('wifi-pass-input').focus();
    }
}

function showWifiMsg(text) {
    const el = document.getElementById('wifi-msg');
    el.textContent = text;
    el.style.display = 'block';
}

function wifiConnect() {
    if (!selectedSSID) return;
    const password = document.getElementById('wifi-pass-input').value;
    showWifiMsg('Connecting to ' + selectedSSID + '... Device will reboot.');

    fetch('/api/wifi/connect', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ssid: selectedSSID, password: password })
    }).catch(() => {});

    // Device will reboot — show message
    setTimeout(() => {
        showWifiMsg('Device is rebooting. Reconnect to your network and navigate to the new IP.');
    }, 2000);
}

function wifiForget() {
    if (!confirm('Forget saved network and reboot into AP mode?')) return;
    showWifiMsg('Clearing credentials... Device will reboot into AP mode.');

    fetch('/api/wifi/disconnect', { method: 'POST' }).catch(() => {});

    setTimeout(() => {
        showWifiMsg('Device is rebooting. Connect to "GeometryCar" WiFi network.');
    }, 2000);
}

// ===== Gyro Calibration =====
function calibrateGyro() {
    if (recording) {
        alert('Stop recording before calibrating.');
        return;
    }
    const btn = document.getElementById('btn-cal');
    const msg = document.getElementById('cal-msg');
    btn.disabled = true;
    msg.textContent = 'Calibrating... keep car stationary';
    msg.style.display = 'inline';

    // Send calibrate command (0x12)
    if (ws && ws.readyState === 1) ws.send(new Uint8Array([0x12]));

    // Calibration takes ~5 seconds (500 samples at 100Hz)
    setTimeout(() => {
        btn.disabled = false;
        msg.textContent = 'Calibration complete';
        setTimeout(() => { msg.style.display = 'none'; }, 3000);
    }, 6000);
}

// ===== Recording Analysis =====
let anOpen = false;

function toggleAnalysis() {
    anOpen = !anOpen;
    document.getElementById('an-body').className = anOpen ? 'open' : '';
    document.getElementById('an-toggle').innerHTML = anOpen ? '&#9650;' : '&#9660;';
}

function analyzeRec() {
    if (recSamples.length < 200) {
        alert('Need at least 2 seconds of data to analyze.');
        return;
    }
    document.getElementById('analysis').className = 'show';
    anOpen = true;
    document.getElementById('an-body').className = 'open';
    document.getElementById('an-toggle').innerHTML = '&#9650;';

    const n = recSamples.length;
    const dur = n / 100;
    const speedMph = parseFloat(document.getElementById('speed-input').value) || 10;
    const truckCfg = getTruckConfig();

    // Compute track path from integrated heading
    const pathData = computeTrackPath(recSamples, speedMph);

    // Detect and classify events
    let { events, azDev, ayDev } = detectEvents(recSamples);
    events = classifyEvents(events, truckCfg, speedMph);

    // Summary statistics (1-second windows)
    const winSize = 100;
    const nWin = Math.floor(n / winSize);
    let smoothSec = 0, fairSec = 0, roughSec = 0;
    let curveSec = 0, straightSec = 0;
    for (let w = 0; w < nWin; w++) {
        let azSum2 = 0, gzSum = 0;
        for (let i = 0; i < winSize; i++) {
            const s = recSamples[w * winSize + i];
            azSum2 += s.az * s.az;
            gzSum += s.gz;
        }
        const azRms = Math.sqrt(azSum2 / winSize);
        const gzMean = gzSum / winSize;
        if (azRms < 1.01) smoothSec++;
        else if (azRms < 1.03) fairSec++;
        else roughSec++;
        if (Math.abs(gzMean) >= 0.3) curveSec++;
        else straightSec++;
    }

    // Count classified defect locations (deduped, not individual hits)
    const deduped = events.deduped || [];
    const classMap = {};
    for (const ev of deduped) {
        const cls = ev.classification || ev.type;
        classMap[cls] = (classMap[cls] || 0) + 1;
    }
    let eventText = Object.entries(classMap)
        .map(([cls, cnt]) => '<b>' + cnt + '</b> ' + cls)
        .join(', ');
    if (!eventText) eventText = 'none';
    eventText += ' <span style="color:#888">(' + events.length + ' hits)</span>';

    const sumEl = document.getElementById('an-summary');
    sumEl.innerHTML =
        '<b>' + n.toLocaleString() + '</b> samples, <b>' + dur.toFixed(1) +
        's</b> at <b>' + speedMph + '</b> scale mph<br>' +
        'Ride: <b style="color:#4ade80">' + smoothSec + 's smooth</b>, ' +
        '<b style="color:#fbbf24">' + fairSec + 's fair</b>, ' +
        '<b style="color:#ef4444">' + roughSec + 's rough</b><br>' +
        'Track: <b>' + straightSec + 's</b> straight, <b>' + curveSec +
        's</b> in curves<br>' +
        'Events: ' + eventText;

    // Draw charts
    drawPathChart('an-path', pathData);
    drawTimelineChart('an-timeline', recSamples, azDev, ayDev, events);
}

// ===== Track Path Computation =====

function computeTrackPath(samples, speedMph) {
    const dt = 0.01;  // 10ms at 100Hz
    // Convert scale mph to model mm/s: mph * 447.04mm/s / 87 (HO scale)
    const modelMmPerSec = speedMph * 447.04 / 87.0;
    const distPerSample = modelMmPerSec * dt;
    const n = samples.length;

    // Extract gz (yaw rate in dps)
    const gz = new Float64Array(n);
    for (let i = 0; i < n; i++) gz[i] = samples[i].gz;

    // Linear detrend gz to remove gyro bias drift
    // Fit gz[i] = a + b*i via least-squares
    let sx = 0, sy = 0, sxx = 0, sxy = 0;
    for (let i = 0; i < n; i++) {
        sx += i; sy += gz[i]; sxx += i * i; sxy += i * gz[i];
    }
    const b = (n * sxy - sx * sy) / (n * sxx - sx * sx);
    const a = (sy - b * sx) / n;
    for (let i = 0; i < n; i++) gz[i] -= (a + b * i);

    // Integrate gz -> heading (radians)
    const heading = new Float64Array(n);
    heading[0] = 0;
    for (let i = 1; i < n; i++) {
        heading[i] = heading[i - 1] + gz[i] * dt * Math.PI / 180.0;
    }

    // Integrate heading -> XY position (mm)
    const pathX = new Float64Array(n);
    const pathY = new Float64Array(n);
    for (let i = 1; i < n; i++) {
        pathX[i] = pathX[i - 1] + distPerSample * Math.cos(heading[i]);
        pathY[i] = pathY[i - 1] + distPerSample * Math.sin(heading[i]);
    }

    // Ride quality per sample (rolling 100-sample az RMS)
    const rideQuality = new Uint8Array(n);  // 0=smooth, 1=fair, 2=rough
    const WIN = 100;
    let runSum = 0;
    const half = Math.floor(WIN / 2);
    for (let i = 0; i < Math.min(half, n); i++) runSum += samples[i].az * samples[i].az;
    for (let i = 0; i < n; i++) {
        const rEdge = i + half;
        if (rEdge < n) runSum += samples[rEdge].az * samples[rEdge].az;
        const lEdge = i - half - 1;
        if (lEdge >= 0) runSum -= samples[lEdge].az * samples[lEdge].az;
        const wLen = Math.min(rEdge + 1, n) - Math.max(i - half, 0);
        const rms = Math.sqrt(runSum / wLen);
        if (rms < 1.01) rideQuality[i] = 0;
        else if (rms < 1.03) rideQuality[i] = 1;
        else rideQuality[i] = 2;
    }

    // Direction detection: find turnaround points
    // A turnaround is where the car reverses — detected by looking at
    // the longitudinal displacement derivative (are we still moving "forward"?)
    // Compute forward progress along initial heading direction
    const direction = new Uint8Array(n);  // 0=outbound, 1=return
    // Use the displacement vector projected onto the initial heading
    // The initial heading direction is (1, 0) since heading[0] = 0
    // A simpler approach: smooth ax and look for sign reversal indicating decel → re-accel
    // But the most robust: track cumulative distance from start along the path
    // and detect when the car starts getting closer to start
    let distFromStart = 0;
    let maxDist = 0;
    let turnaroundIdx = -1;
    const dists = new Float64Array(n);
    for (let i = 0; i < n; i++) {
        dists[i] = Math.sqrt(pathX[i] * pathX[i] + pathY[i] * pathY[i]);
        if (dists[i] > maxDist) {
            maxDist = dists[i];
            turnaroundIdx = i;
        }
    }
    // Verify it's actually a turnaround: must move at least 10% back toward start
    // after the max distance point
    const endDist = dists[n - 1];
    const returnAmount = maxDist > 0 ? (maxDist - endDist) / maxDist : 0;
    if (returnAmount > 0.1 && turnaroundIdx > n * 0.1 && turnaroundIdx < n * 0.9) {
        // Mark everything after turnaround as return leg
        for (let i = turnaroundIdx; i < n; i++) direction[i] = 1;
    }
    // else: whole survey is one direction (outbound)

    return { pathX, pathY, heading, rideQuality, direction };
}

// ===== Event Detection =====

function detectEvents(samples) {
    const n = samples.length;
    const WIN = 100;  // 1-second running mean window
    const half = Math.floor(WIN / 2);

    // Compute deviation from local mean (removes gravity, grade, curve forces)
    const azDev = new Float64Array(n);
    const ayDev = new Float64Array(n);
    // Running sums for O(N) mean computation
    let azRunSum = 0, ayRunSum = 0;
    for (let i = 0; i < Math.min(half, n); i++) {
        azRunSum += samples[i].az; ayRunSum += samples[i].ay;
    }
    for (let i = 0; i < n; i++) {
        const rEdge = i + half;
        if (rEdge < n) { azRunSum += samples[rEdge].az; ayRunSum += samples[rEdge].ay; }
        const lEdge = i - half - 1;
        if (lEdge >= 0) { azRunSum -= samples[lEdge].az; ayRunSum -= samples[lEdge].ay; }
        const wLen = Math.min(rEdge + 1, n) - Math.max(i - half, 0);
        azDev[i] = samples[i].az - azRunSum / wLen;
        ayDev[i] = samples[i].ay - ayRunSum / wLen;
    }

    const events = [];
    const MIN_SPACING = 10;  // 100ms between events
    const VERT_THRESH = 0.02;  // g deviation from local mean
    const LAT_THRESH = 0.02;   // g deviation from local mean

    // Detect vertical bumps
    let lastVert = -MIN_SPACING;
    for (let i = 1; i < n - 1; i++) {
        const v = Math.abs(azDev[i]);
        if (v > VERT_THRESH &&
            v >= Math.abs(azDev[i - 1]) && v >= Math.abs(azDev[i + 1]) &&
            (i - lastVert) >= MIN_SPACING) {
            // Prominence check: peak > 2x local RMS (50 samples)
            const pS = Math.max(0, i - 25), pE = Math.min(n, i + 25);
            let sum2 = 0;
            for (let j = pS; j < pE; j++) sum2 += azDev[j] * azDev[j];
            const localRms = Math.sqrt(sum2 / (pE - pS));
            if (v > localRms * 2.0) {
                events.push({
                    type: 'bump', index: i, time: i * 0.01, value: azDev[i],
                    label: (azDev[i] > 0 ? '+' : '') + azDev[i].toFixed(3) + 'g'
                });
                lastVert = i;
            }
        }
    }

    // Detect lateral kicks
    let lastLat = -MIN_SPACING;
    for (let i = 1; i < n - 1; i++) {
        const v = Math.abs(ayDev[i]);
        if (v > LAT_THRESH &&
            v >= Math.abs(ayDev[i - 1]) && v >= Math.abs(ayDev[i + 1]) &&
            (i - lastLat) >= MIN_SPACING) {
            const pS = Math.max(0, i - 25), pE = Math.min(n, i + 25);
            let sum2 = 0;
            for (let j = pS; j < pE; j++) sum2 += ayDev[j] * ayDev[j];
            const localRms = Math.sqrt(sum2 / (pE - pS));
            if (v > localRms * 2.0) {
                const side = ayDev[i] > 0 ? 'R' : 'L';
                events.push({
                    type: 'kick', index: i, time: i * 0.01, value: ayDev[i],
                    label: side + ' ' + Math.abs(ayDev[i]).toFixed(3) + 'g'
                });
                lastLat = i;
            }
        }
    }

    events.sort((a, b) => a.index - b.index);
    return { events, azDev, ayDev };
}

// ===== Event Classification =====

function classifyEvents(events, truckConfig, speedMph) {
    if (events.length === 0) return events;

    // Compute expected delays in samples (at 100Hz)
    const modelMmPerSec = speedMph * 447.04 / 87.0;
    const axleDelay = modelMmPerSec > 0
        ? (truckConfig.axleSpacingMm / modelMmPerSec) * 100 : 32;
    const truckDelay = modelMmPerSec > 0
        ? (truckConfig.truckSpacingMm / modelMmPerSec) * 100 : 105;
    const tolerance = 0.35;  // ±35% timing tolerance

    // Group events by temporal proximity
    // Events within 1.5x axle delay are candidates for same defect
    const groupWindow = axleDelay * 1.5;
    const maxGroupSpan = truckDelay + axleDelay * 1.5;
    const groups = [];
    let currentGroup = null;

    for (const ev of events) {
        if (!currentGroup || (ev.index - currentGroup[0].index) > maxGroupSpan ||
            (ev.index - currentGroup[currentGroup.length - 1].index) > groupWindow) {
            currentGroup = [ev];
            groups.push(currentGroup);
        } else {
            currentGroup.push(ev);
        }
    }

    // Classify each group
    for (const group of groups) {
        const bumps = group.filter(e => e.type === 'bump');
        const kicks = group.filter(e => e.type === 'kick');
        const hasBumps = bumps.length > 0;
        const hasKicks = kicks.length > 0;

        let classification;

        if (hasBumps && hasKicks) {
            // Simultaneous vertical + lateral → complex defect
            // Check if the bump and kick are close together (within half axle delay)
            const bIdx = bumps[0].index, kIdx = kicks[0].index;
            if (Math.abs(bIdx - kIdx) < axleDelay * 0.5) {
                classification = 'frog?';
            } else {
                classification = 'xing?';
            }
        } else if (hasBumps) {
            if (bumps.length >= 4) {
                // Check for axle+truck spacing pattern
                classification = 'joint';
            } else if (bumps.length >= 2) {
                // Check if spacing matches axle delay
                const spacing = bumps[1].index - bumps[0].index;
                if (Math.abs(spacing - axleDelay) < axleDelay * tolerance) {
                    classification = 'joint?';
                } else if (Math.abs(spacing - truckDelay) < truckDelay * tolerance) {
                    classification = 'joint?';
                } else {
                    classification = 'bump';
                }
            } else {
                classification = 'bump';
            }
        } else if (hasKicks) {
            if (kicks.length >= 2) {
                const spacing = kicks[1].index - kicks[0].index;
                if (Math.abs(spacing - axleDelay) < axleDelay * tolerance) {
                    classification = 'kink';
                } else {
                    classification = 'kink?';
                }
            } else {
                classification = 'kink?';
            }
        }

        // Apply classification label to all events in the group
        // and mark group membership
        for (let gi = 0; gi < group.length; gi++) {
            group[gi].classification = classification;
            group[gi].label = classification;
            group[gi].groupId = groups.indexOf(group);
        }
    }

    // Build deduped event list: one representative per group
    // Pick the event with the largest absolute amplitude as the representative
    const deduped = [];
    for (const group of groups) {
        let best = group[0];
        for (let i = 1; i < group.length; i++) {
            if (Math.abs(group[i].value) > Math.abs(best.value)) best = group[i];
        }
        deduped.push({
            ...best,
            groupSize: group.length,
            label: best.classification + (group.length > 1 ? ' ×' + group.length : '')
        });
    }

    events.deduped = deduped;
    return events;
}

// ===== Track Path Chart (plan view map) =====

function computeNiceScaleBar(rangeMm) {
    const nice = [10, 25, 50, 100, 254, 500, 1000];  // 254mm = 10"
    const target = rangeMm * 0.2;
    let best = nice[0];
    for (const v of nice) {
        if (Math.abs(v - target) < Math.abs(best - target)) best = v;
    }
    return best;
}

function drawPathChart(canvasId, pathData) {
    const canvas = document.getElementById(canvasId);
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    const c = canvas.getContext('2d');
    c.scale(dpr, dpr);
    const w = rect.width, h = rect.height;
    const m = { top: 12, right: 12, bottom: 12, left: 12 };
    const pw = w - m.left - m.right, ph = h - m.top - m.bottom;

    c.clearRect(0, 0, w, h);
    c.fillStyle = '#0a0f1e';
    c.fillRect(m.left, m.top, pw, ph);

    const { pathX, pathY, heading, rideQuality, direction } = pathData;
    const n = pathX.length;
    if (n < 2) return;

    // Bounding box
    let xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity;
    for (let i = 0; i < n; i++) {
        if (pathX[i] < xMin) xMin = pathX[i]; if (pathX[i] > xMax) xMax = pathX[i];
        if (pathY[i] < yMin) yMin = pathY[i]; if (pathY[i] > yMax) yMax = pathY[i];
    }
    // Add 10% padding, ensure minimum range
    const xRange = Math.max(xMax - xMin, 1);
    const yRange = Math.max(yMax - yMin, 1);
    xMin -= xRange * 0.1; xMax += xRange * 0.1;
    yMin -= yRange * 0.1; yMax += yRange * 0.1;

    // Fit to canvas preserving aspect ratio
    const scaleX = pw / (xMax - xMin);
    const scaleY = ph / (yMax - yMin);
    const scale = Math.min(scaleX, scaleY);
    const usedW = (xMax - xMin) * scale;
    const usedH = (yMax - yMin) * scale;
    const offX = m.left + (pw - usedW) / 2;
    const offY = m.top + (ph - usedH) / 2;

    function toSX(x) { return offX + (x - xMin) * scale; }
    function toSY(y) { return offY + usedH - (y - yMin) * scale; }

    // Draw path segments colored by travel direction
    const DIR_COLORS = ['#4488ff', '#fbbf24'];  // 0=outbound (blue), 1=return (yellow)
    const STEP = Math.max(1, Math.floor(n / (pw * 2)));
    c.lineWidth = 2.5;
    c.lineCap = 'round';
    for (let i = STEP; i < n; i += STEP) {
        c.strokeStyle = DIR_COLORS[direction[i]];
        c.beginPath();
        c.moveTo(toSX(pathX[i - STEP]), toSY(pathY[i - STEP]));
        c.lineTo(toSX(pathX[i]), toSY(pathY[i]));
        c.stroke();
    }

    // Start marker (green circle + label)
    c.fillStyle = '#4ade80';
    c.beginPath();
    c.arc(toSX(pathX[0]), toSY(pathY[0]), 4, 0, 2 * Math.PI);
    c.fill();
    c.fillStyle = '#fff';
    c.font = '9px monospace';
    c.textAlign = 'left';
    c.fillText('Start', toSX(pathX[0]) + 6, toSY(pathY[0]) + 3);

    // End marker (red circle)
    c.fillStyle = '#ef4444';
    c.beginPath();
    c.arc(toSX(pathX[n - 1]), toSY(pathY[n - 1]), 4, 0, 2 * Math.PI);
    c.fill();
    c.fillStyle = '#fff';
    c.textAlign = 'left';
    c.fillText('End', toSX(pathX[n - 1]) + 6, toSY(pathY[n - 1]) + 3);

    // Direction arrows every 5 seconds
    c.fillStyle = 'rgba(255,255,255,0.25)';
    const arrowInt = 500;
    for (let i = arrowInt; i < n; i += arrowInt) {
        const sx = toSX(pathX[i]), sy = toSY(pathY[i]);
        const ang = heading[i];
        c.save();
        c.translate(sx, sy);
        c.rotate(-ang);  // screen Y is inverted
        c.beginPath();
        c.moveTo(5, 0); c.lineTo(-3, -3); c.lineTo(-3, 3);
        c.closePath(); c.fill();
        c.restore();
    }

    // Time tick marks every 5s
    c.fillStyle = 'rgba(255,255,255,0.4)';
    c.font = '8px monospace';
    c.textAlign = 'center';
    const tickInt = 500;
    for (let i = tickInt; i < n; i += tickInt) {
        const sx = toSX(pathX[i]), sy = toSY(pathY[i]);
        c.beginPath();
        c.arc(sx, sy, 2, 0, 2 * Math.PI);
        c.fill();
        c.fillText((i / 100) + 's', sx, sy - 5);
    }

    // Scale bar (bottom-right)
    const totalRange = Math.max(xMax - xMin, yMax - yMin);
    const refMm = computeNiceScaleBar(totalRange);
    const refPx = refMm * scale;
    if (refPx > 20 && refPx < pw * 0.5) {
        const sbX = m.left + pw - refPx - 8;
        const sbY = m.top + ph - 8;
        c.strokeStyle = '#888';
        c.lineWidth = 2;
        c.beginPath();
        c.moveTo(sbX, sbY); c.lineTo(sbX + refPx, sbY);
        c.stroke();
        // End caps
        c.beginPath();
        c.moveTo(sbX, sbY - 3); c.lineTo(sbX, sbY + 3);
        c.moveTo(sbX + refPx, sbY - 3); c.lineTo(sbX + refPx, sbY + 3);
        c.stroke();
        c.fillStyle = '#888';
        c.font = '9px monospace';
        c.textAlign = 'center';
        const label = refMm >= 25.4 ? (refMm / 25.4).toFixed(0) + '"' : refMm + 'mm';
        c.fillText(label, sbX + refPx / 2, sbY - 4);
    }
}

// ===== Accelerometer Timeline with Sticky Notes =====

function drawTimelineChart(canvasId, samples, azDev, ayDev, events) {
    const canvas = document.getElementById(canvasId);
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    const c = canvas.getContext('2d');
    c.scale(dpr, dpr);
    const w = rect.width, h = rect.height;

    // Reserve space at top for sticky notes (2 tiers)
    const NOTE_H = 14, NOTE_GAP = 2;
    const noteZone = (NOTE_H + NOTE_GAP) * 2 + 4;
    const mg = { top: noteZone + 4, right: 8, bottom: 18, left: 40 };
    const pw = w - mg.left - mg.right, ph = h - mg.top - mg.bottom;

    c.clearRect(0, 0, w, h);
    c.fillStyle = '#0a0f1e';
    c.fillRect(mg.left, mg.top, pw, ph);

    const n = samples.length;
    const totalSec = n / 100;

    // Auto-scale Y for both channels
    let yMin = 0, yMax = 0;
    for (let i = 0; i < n; i++) {
        if (azDev[i] < yMin) yMin = azDev[i]; if (azDev[i] > yMax) yMax = azDev[i];
        if (ayDev[i] < yMin) yMin = ayDev[i]; if (ayDev[i] > yMax) yMax = ayDev[i];
    }
    const pad = Math.max((yMax - yMin) * 0.1, 0.005);
    yMin -= pad; yMax += pad;
    const yR = yMax - yMin;

    function timeToX(t) { return mg.left + (t / totalSec) * pw; }
    function valToY(v) { return mg.top + ph - ((v - yMin) / yR) * ph; }

    // Zero line
    c.strokeStyle = '#333';
    c.lineWidth = 1;
    c.beginPath();
    c.moveTo(mg.left, valToY(0)); c.lineTo(mg.left + pw, valToY(0));
    c.stroke();

    // Y axis labels
    c.fillStyle = '#666';
    c.font = '9px monospace';
    c.textAlign = 'right';
    for (let i = 0; i <= 4; i++) {
        const val = yMax - (yR * i / 4);
        const y = mg.top + (ph * i / 4);
        c.fillText(val.toFixed(3), mg.left - 3, y + 3);
    }

    // Draw traces (downsample to ~2 points per pixel)
    const STEP = Math.max(1, Math.floor(n / (pw * 2)));

    // Vertical accel deviation (blue)
    c.strokeStyle = '#4488ff';
    c.lineWidth = 1;
    c.beginPath();
    for (let i = 0; i < n; i += STEP) {
        const x = timeToX(i / 100), y = valToY(azDev[i]);
        if (i === 0) c.moveTo(x, y); else c.lineTo(x, y);
    }
    c.stroke();

    // Lateral accel deviation (green)
    c.strokeStyle = '#44ff88';
    c.lineWidth = 1;
    c.beginPath();
    for (let i = 0; i < n; i += STEP) {
        const x = timeToX(i / 100), y = valToY(ayDev[i]);
        if (i === 0) c.moveTo(x, y); else c.lineTo(x, y);
    }
    c.stroke();

    // X axis: time labels
    c.fillStyle = '#666';
    c.textAlign = 'center';
    c.font = '9px monospace';
    const step = totalSec <= 10 ? 1 : totalSec <= 30 ? 5 : totalSec <= 120 ? 10 : 30;
    for (let s = step; s <= totalSec; s += step) {
        c.fillText(s + 's', timeToX(s), h - 3);
    }

    // Draw small marker dots for all raw event hits (every wheel crossing)
    const BUMP_DOT = '#ef4444';
    const KICK_DOT = '#f97316';
    for (const ev of events) {
        const x = timeToX(ev.time), y = valToY(ev.value);
        c.fillStyle = ev.type === 'bump' ? BUMP_DOT : KICK_DOT;
        c.beginPath(); c.arc(x, y, 2.5, 0, Math.PI * 2); c.fill();
    }

    // Draw sticky notes for deduped events only (one per defect location)
    const deduped = events.deduped || events;
    drawStickyNotes(c, deduped, timeToX, valToY, mg, pw, NOTE_H, NOTE_GAP);
}

function drawStickyNotes(c, events, timeToX, valToY, mg, plotWidth, noteH, noteGap) {
    if (events.length === 0) return;

    const BUMP_COLOR = '#ef4444';
    const KICK_COLOR = '#f97316';
    const NOTE_W = 52;  // Fits "joint? ×2" etc.

    // roundRect polyfill
    function roundRect(ctx, x, y, w, h, r) {
        if (ctx.roundRect) { ctx.beginPath(); ctx.roundRect(x, y, w, h, r); return; }
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
    }

    // Assign tiers to avoid overlaps
    let tier0End = -Infinity, tier1End = -Infinity;
    const placed = [];
    for (const ev of events) {
        const x = timeToX(ev.time);
        const noteLeft = x - NOTE_W / 2;
        let tier;
        if (noteLeft > tier0End + 4) { tier = 0; tier0End = noteLeft + NOTE_W; }
        else if (noteLeft > tier1End + 4) { tier = 1; tier1End = noteLeft + NOTE_W; }
        else continue;  // skip — too dense
        placed.push({ ...ev, tier, screenX: x });
    }

    for (const p of placed) {
        const color = p.type === 'bump' ? BUMP_COLOR : KICK_COLOR;
        const noteY = 2 + p.tier * (noteH + noteGap);
        const noteX = p.screenX - NOTE_W / 2;
        const dataY = valToY(p.value);

        // Dashed connector line
        c.strokeStyle = color + '88';
        c.lineWidth = 1;
        c.setLineDash([2, 2]);
        c.beginPath();
        c.moveTo(p.screenX, noteY + noteH);
        c.lineTo(p.screenX, dataY);
        c.stroke();
        c.setLineDash([]);

        // Note rectangle
        c.fillStyle = color;
        roundRect(c, noteX, noteY, NOTE_W, noteH, 3);
        c.fill();

        // Small triangle pointer
        c.beginPath();
        c.moveTo(p.screenX - 3, noteY + noteH);
        c.lineTo(p.screenX + 3, noteY + noteH);
        c.lineTo(p.screenX, noteY + noteH + 3);
        c.closePath();
        c.fill();

        // Note text
        c.fillStyle = '#fff';
        c.font = '8px monospace';
        c.textAlign = 'center';
        c.fillText(p.label, p.screenX, noteY + 10);
    }
}

// ===== Init =====
wsConnect();
</script>
</body>
</html>
